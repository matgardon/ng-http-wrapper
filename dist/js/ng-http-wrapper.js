var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var models;
        (function (models) {
            /**
             * TODO MGA : export an interface too ?
             */
            var ApiConfig = (function () {
                function ApiConfig(coreApiUrl, 
                    //TODO MGA : to inject as generic list of custom headers to pass to $http service ?
                    jwtToken, currentUserRole) {
                    this.coreApiUrl = coreApiUrl;
                    this.jwtToken = jwtToken;
                    this.currentUserRole = currentUserRole;
                }
                return ApiConfig;
            }());
            models.ApiConfig = ApiConfig;
        })(models = core.models || (core.models = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var models;
        (function (models) {
            var FileContent = (function () {
                function FileContent(name, size, type, content) {
                    this.name = name;
                    this.size = size;
                    this.type = type;
                    this.content = content;
                }
                return FileContent;
            }());
            models.FileContent = FileContent;
        })(models = core.models || (core.models = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            var HttpMethod;
            (function (HttpMethod) {
                HttpMethod[HttpMethod["GET"] = 0] = "GET";
                HttpMethod[HttpMethod["POST"] = 1] = "POST";
                HttpMethod[HttpMethod["PUT"] = 2] = "PUT";
                HttpMethod[HttpMethod["DELETE"] = 3] = "DELETE";
            })(HttpMethod || (HttpMethod = {}));
            ;
            /**
             * TODO MGA : this may not need to be a dedicated service, it can also be incorporated into the httpInterceptor. Decide best approach depending on planned use.
             */
            var HttpWrapperService = (function () {
                //#endregion
                //#region ctor
                /* @ngInject */
                HttpWrapperService.$inject = ["$http", "$window", "$log", "$q", "$location", "Upload", "toaster"];
                function HttpWrapperService($http, $window, $log, $q, $location, Upload, toaster) {
                    var _this = this;
                    this.$http = $http;
                    this.$window = $window;
                    this.$log = $log;
                    this.$q = $q;
                    this.$location = $location;
                    this.Upload = Upload;
                    this.toaster = toaster;
                    /**
                    * Prepares a {@link ng#$http#config config} object for $http call.
                    * The operations include setting default values when not provided, and setting http headers if needed for :
                    *  - Ajax calls
                    *  - Authorization token
                    *  - Current UserRole.
                    * @param options
                    * @returns {ng.$http.config} the configuration object ready to be injected into a $http call.
                    */
                    this.configureHttpCall = function (method, url, config) {
                        if (!url || method === null || method === undefined) {
                            _this.$log.error('URL & METHOD parameters are necessary for httpWrapper calls. Aborting.');
                            return null;
                        }
                        //Init config even if not provided
                        config = config || {};
                        //TODO MGA: hard cast is not safe, we may forget to set url & method parameters. TOFIX.
                        // automatically get all non-filtered parameters & keep them for this new object.
                        var configFull = config;
                        //TODO MGA: support mapping between upload & post here ?
                        configFull.method = HttpMethod[method];
                        if (config.apiEndpoint && (!_this.apiConfig ||
                            !_this.apiConfig.jwtToken ||
                            !_this.apiConfig.currentUserRole)) {
                            _this.$log.error("[InternalError] [" + configFull.method + " / " + url + "] - coreApi call intended without necessary capi credentials. Aborting.");
                            return null;
                        }
                        configFull.headers = config.headers || {};
                        if (!config.apiEndpoint) {
                            configFull.url = _this.buildUrlFromContext(url);
                        }
                        else {
                            //TODO MGA : core api endpoint 'api/' hardcoded, to put in configFull ! should not know that here.
                            configFull.url = _this.apiConfig.coreApiUrl + 'api/' + url;
                            if (_this.apiConfig.jwtToken && _this.apiConfig.currentUserRole) {
                                //TODO MGA: hard coded headers, not good, to inject
                                configFull.headers['OA-UserRole'] = _this.apiConfig.currentUserRole;
                                configFull.headers['Authorization'] = 'Bearer ' + _this.apiConfig.jwtToken;
                            }
                        }
                        if (!config.disableXmlHttpRequestHeader)
                            configFull.headers['X-Requested-With'] = 'XMLHttpRequest';
                        //TODO MGA: OE specific code, to remove
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = true;
                        return configFull;
                    };
                    /**
                     * Success handler.
                     * Captures the input parameters at the moment of its declaration & return the real handler to be called upon promise completion.
                     * Input parameters:
                     *  - callingConfig: configuration used to make the ajax call, in case the returned promise is null/empty and doesn't contain necessary data for debugging.
                     *  - getCompleteResponseObject: flag indication if we must return the full response object along with headers and status or only the inner data. By default & if not specified, only returns inner data.
                     */
                    this.onSuccess = function (httpPromise) {
                        if (!httpPromise) {
                            _this.$log.error("[HTTP no-response] Unexpected $http error, no response promise returned.");
                            _this.toaster.error('Unexpected behavior', 'Please contact your local support team.');
                            return null;
                        }
                        //TODO MGA: handle when API is fixed. See http://stackoverflow.com/questions/11746894/what-is-the-proper-rest-response-code-for-a-valid-request-but-an-empty-data
                        //if ((promiseCallback.data === null || promiseCallback.data === undefined) && promiseCallback.status !== 204) {
                        //    this.$log.error('Unexpected response from the server, expected response data but none found.');
                        //    this.toaster.warning('Unexpected response', 'Please contact your local support team.');
                        //    return this.$q.reject(promiseCallback); // Reject promise if not well-formed data
                        //}
                        //TODO MGA: same behavior also on a GET request ? if request is GET and response is 200 with no data, return error ? (pass in parameter request context to log this error).
                        //TODO MGA: get full url of request
                        _this.$log.debug("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                        // return only the data expected for caller
                        return httpPromise.data;
                    };
                    /**
                     * Error handler
                     * @param httpPromise
                     * @returns {}
                     */
                    this.onError = function (httpPromise) {
                        // We suppose in case of no response that the srv didn't send any response.
                        // TODO MGA: may also be a fault in internal $http / ajax client side lib, to distinguish.
                        if (!httpPromise || !httpPromise.data) {
                            httpPromise.data = 'Server not responding';
                            httpPromise.status = 503;
                        }
                        var contentType = httpPromise.headers('Content-Type');
                        if (contentType && (contentType.indexOf('application/json') > -1 || contentType.indexOf('text/plain') > -1)) {
                            var message = ""; //default message
                            //TODO MGA: handle error handling more generically based on input error message contract instead of expecting specific error strcture.
                            //if (response.data.ModelState) {
                            //    //TODO MGA : handle this when well formatted server-side
                            //} else
                            if (httpPromise.data.Message && angular.isString(httpPromise.data.Message)) {
                                message = httpPromise.data.Message;
                            }
                            else if (angular.isString(httpPromise.data)) {
                                message = httpPromise.data;
                            }
                            //TODO MGA: handle more response codes gracefully.
                            if (httpPromise.status === 404) {
                                _this.toaster.warning('Not Found', message);
                            }
                            else {
                                _this.toaster.error('Server response error', message + '\n Status: ' + httpPromise.status);
                            }
                        }
                        else {
                            _this.toaster.error('Internal server error', 'Status: ' + httpPromise.status);
                        }
                        //TODO MGA: get full url of request
                        _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                        // We don't recover from error, so we propagate it : below handlers have the choice of reading the error with an error handler or not. See $q promises behavior here : https://github.com/kriskowal/q
                        // This behavior is desired so that we show error inside specific server communication modals at specific places in the app, otherwise show a global alert message, or even do not show anything if not necessary (do not ad an error handler in below handlers of this promise).
                        return _this.$q.reject(httpPromise);
                    };
                    /**
                     * Function called at the end of an ajax call, regardless of it's success or failure.
                     * @param response
                     */
                    this.finally = function () {
                        //TODO MGA: OE-specific code
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = false;
                    };
                    // init core api config data on ctor
                    //TODO MGA : hard coded path for CorerApiAuthCtrl to inject
                    this.initPromise = this.$http.get(this.buildUrlFromContext('CoreApiAuth/GetCoreApiConfig'))
                        .success(function (coreApiConfig) {
                        _this.apiConfig = coreApiConfig;
                    }).error(function (error) {
                        _this.$log.error('Unable to retrieve API config. Aborting httpWrapperService initialization.');
                        return $q.reject(error);
                    });
                }
                //#endregion
                //#region public methods
                HttpWrapperService.prototype.get = function (url, config) {
                    return this.ajax(HttpMethod.GET, url, config);
                };
                HttpWrapperService.prototype.delete = function (url, config) {
                    return this.ajax(HttpMethod.DELETE, url, config);
                };
                HttpWrapperService.prototype.post = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    ;
                    return this.ajax(HttpMethod.POST, url, config);
                };
                HttpWrapperService.prototype.put = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PUT, url, config);
                };
                HttpWrapperService.prototype.upload = function (url, file, config) {
                    var _this = this;
                    if (!file && (!config || !config.file)) {
                        this.$log.error('Cannot start upload with null {file} parameter.');
                        return null;
                    }
                    config = config || {};
                    config.file = file || config.file; //TODO MGA : do not expose file in IHttpWrapperConfig ?
                    config.data = config.data || {};
                    if (config.uploadInBase64Json) {
                        //TODO MGA: make sure this delays next call and upload is not done before base64 encoding is finished, even if promise is already resolved ???
                        return this.Upload.base64DataUrl(file).then(function (fileBase64Url) {
                            //TODO MGA: hard-coded key to fetch base64 encoding, to parametrize with server-side !
                            config.data.fileBase64Url = fileBase64Url;
                            //normal post in case of base64-encoded data
                            return _this.ajax(HttpMethod.POST, url, config);
                        });
                    }
                    else {
                        config.data.fileFormDataName = 'file'; // file formData name ('Content-Disposition'), server side request form name
                        //TODO MGA : do not block if not call to internal API (initCall)
                        return this.initPromise.then(function () {
                            //TODO MGA : not safe hard cast
                            //TODO MGA : behavior duplication with this.ajax, not DRY, to improve
                            return _this.Upload.upload(_this.configureHttpCall(HttpMethod.POST, url, config))
                                .then(_this.onSuccess, _this.onError, config.uploadProgress) //TODO MGA : uploadProgress callback ok ?
                                .finally(_this.finally);
                        });
                    }
                };
                /**
                 * This method is used to download a file in the form of a byte-stream from an endpoint and wrap it into a FileContent object with name, type & size properties read from the HTTP response headers of the serveur.
                 * It is the responsability of the consumer to do something with the wrapped byteArray (for example download the file, or show it inside the webPage etc).
                 * @param url
                 * @param expectedName
                 * @param expectedSize
                 * @param expectedType
                 * @param config
                 */
                HttpWrapperService.prototype.getFile = function (url, config) {
                    var _this = this;
                    return this.initPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(HttpMethod.GET, url, config);
                        // specifically expect raw response type, otherwise byte stream responses are corrupted.
                        angularHttpConfig.responseType = 'arraybuffer';
                        //Expected ArrayBuffer response = byte array
                        return _this.$http(angularHttpConfig)
                            .then(function (httpResponse) {
                            //benefit from successCallback validation before continuing
                            var arrayBuffer = _this.onSuccess(httpResponse);
                            //TODO MGA: promise rejection vs. return null ?
                            if (!arrayBuffer)
                                return null; //stop processing if unable to retrieve byte array
                            //read file info from response-headers
                            var fileContent = {
                                name: _this.getFileNameFromHeaderContentDisposition(httpResponse.headers('content-disposition')) || null,
                                size: Number(httpResponse.headers('content-length')) || 0,
                                type: httpResponse.headers('content-type') || 'application/octet-stream',
                                content: arrayBuffer
                            };
                            return fileContent;
                        }, _this.onError)
                            .finally(_this.finally);
                    });
                };
                //TODO MGA : method too specific to OM apps context, may not work outside of it, to adapt for public use ?
                /**
                 * Tries to parse the input url :
                 * If it seems to be a full URL, then return as is (considers it external Url)
                 * Otherwise, tries to find the base URL of the current BlueSky app with or without the included Controller and returns the full Url
                 * @param urlInput : TODO MGA: document different kind of urls that this method can take as input (full, partial etc)
                 */
                HttpWrapperService.prototype.buildUrlFromContext = function (urlInput) {
                    // 1 - Url starts with http:// or https:// => return as is.
                    if (urlInput.slice(0, 'http://'.length) === 'http://' ||
                        urlInput.slice(0, 'https://'.length) === 'https://') {
                        return urlInput;
                    }
                    // 2 - Otherwise, try to find correct controller
                    // Boolean used to try to determine correct full url (add / or not before the url fragment depending on if found or not)
                    var urlFragmentStartsWithSlash = urlInput.slice(0, '/'.length) === '/';
                    // Regex trying to determine if the input fragment contains a / between two character suites => controller given as input, otherwise, action on same controller expected
                    var controllerIsPresentRegex = /\w+\/\w+/;
                    var actionIsOnSameController = !controllerIsPresentRegex.test(urlInput);
                    var baseUrl = this.getUrlPath(actionIsOnSameController);
                    return baseUrl + (urlFragmentStartsWithSlash ? urlInput : ('/' + urlInput));
                };
                //#endregion
                //#region private methods
                /**
                 * Utility method.
                 * Main caller that all wrapper calls (get, delete, post, put) must use to share common behavior.
                 * @param config
                 */
                HttpWrapperService.prototype.ajax = function (method, url, config) {
                    var _this = this;
                    //TODO MGA : make sure initPromise resolve automatically without overhead once first call sucessfull.
                    //TODO MGA : do not block if not call to internal API (initCall)
                    return this.initPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(method, url, config);
                        return _this.$http(angularHttpConfig)
                            .then(_this.onSuccess, _this.onError)
                            .finally(_this.finally);
                    });
                };
                // TODO MGA : using method from Layout.js : to document to not handle duplicate code !!
                //TODO MGA: unrobust, needs solid refacto to make it more generic when on origin domain !
                HttpWrapperService.prototype.getUrlPath = function (actionIsOnSameController) {
                    var baseUrlOmAppsRegex = /(\/\w+\/\(S\(\w+\)\))\/\w*/;
                    var baseUrlAspAppsRegex = /(\/\w+)\/\w*/;
                    var url = this.$window.location.pathname;
                    var baseUrlOmAppsMatches = baseUrlOmAppsRegex.exec(url);
                    var baseUrlAspAppsMatches = baseUrlAspAppsRegex.exec(url);
                    var baseUrlWithControllerName = null;
                    var baseUrl = null;
                    // 2 matches = regex matches + the capturing group
                    if (baseUrlOmAppsMatches && baseUrlOmAppsMatches.length && baseUrlOmAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlOmAppsMatches[0];
                        baseUrl = baseUrlOmAppsMatches[1];
                    }
                    else if (baseUrlAspAppsMatches && baseUrlAspAppsMatches.length && baseUrlAspAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlAspAppsMatches[0];
                        baseUrl = baseUrlAspAppsMatches[1];
                    }
                    if (actionIsOnSameController && baseUrlWithControllerName) {
                        return baseUrlWithControllerName;
                    }
                    else if (baseUrl) {
                        return baseUrl;
                    }
                    return '';
                };
                //TODO MGA: OM-specific ASP MVC code, not used ATM, to remove
                HttpWrapperService.prototype.getCurrentSessionID = function () {
                    //TODO MGA : magic regexp to fetch SessionID in URL, to store elsewhere !
                    var sessionRegex = /https:\/\/[\w.]+\/[\w.]+\/(\(S\(\w+\)\))\/.*/;
                    //var sessionRegex = /https:\/\/[\w.]+\/OrderEntry\/(\(S\(\w+\)\))\/.*/;
                    // TODO MGA : update regexp to the one below
                    //var baseUrlRegex = /(https:\/\/[\w.-]+\/[\w.-]+\/\(S\(\w+\)\)\/)\w+/;
                    var path = this.$location.absUrl();
                    var regexpArray = sessionRegex.exec(path);
                    if (!regexpArray) {
                        this.$log.error('Unable to recognized searched pattern in current url location to retrieve sessionID.');
                        return '';
                    }
                    if (regexpArray.length === 1) {
                        this.$log.error('Unable to find sessionID in searched pattern in current url.');
                        return '';
                    }
                    if (regexpArray.length > 2) {
                        this.$log.error('Too many matches found for the sessionID search in the current url.');
                        return '';
                    }
                    return regexpArray[1];
                };
                /**
                 * Trim the content-disposition header to return only the filename.
                 * @param contentDispositionHeader
                 */
                HttpWrapperService.prototype.getFileNameFromHeaderContentDisposition = function (contentDispositionHeader) {
                    if (!contentDispositionHeader)
                        return null;
                    var result = contentDispositionHeader.split(';')[1].trim().split('=')[1];
                    return result.replace(/"/g, '');
                };
                return HttpWrapperService;
            }());
            services.HttpWrapperService = HttpWrapperService;
            angular.module('ng.httpWrapper', ['toaster', 'ngAnimate', 'ngFileUpload'])
                .service('httpWrapperService', HttpWrapperService);
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwaS1jb25maWcubW9kZWwudHMiLCJmaWxlLWNvbnRlbnQubW9kZWwudHMiLCJodHRwLXdyYXBwZXIuc2VydmljZS50cyIsIm5nLWh0dHAtd3JhcHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFVO0FBQVYsQ0FBQSxVQUFVLFNBQU87SUFBQyxJQUFBO0lBQUEsQ0FBQSxVQUFBLE1BQUk7UUFBQyxJQUFBO1FBQUEsQ0FBQSxVQUFBLFFBQU87Ozs7WUFJMUIsSUFBQSxhQUFBLFlBQUE7Z0JBQ0ksU0FBQSxVQUNXOztvQkFFQSxVQUNBLGlCQUF1QjtvQkFIdkIsS0FBQSxhQUFBO29CQUVBLEtBQUEsV0FBQTtvQkFDQSxLQUFBLGtCQUFBOztnQkFFZixPQUFBOztZQVBhLE9BQUEsWUFBUztXQUpILFNBQUEsS0FBQSxXQUFBLEtBQUEsU0FBTTtPQUFYLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTzs7QUNBakIsSUFBVTtBQUFWLENBQUEsVUFBVSxTQUFPO0lBQUMsSUFBQTtJQUFBLENBQUEsVUFBQSxNQUFJO1FBQUMsSUFBQTtRQUFBLENBQUEsVUFBQSxRQUFPO1lBQzFCLElBQUEsZUFBQSxZQUFBO2dCQUNJLFNBQUEsWUFDVyxNQUNBLE1BQ0EsTUFDQSxTQUFvQjtvQkFIcEIsS0FBQSxPQUFBO29CQUNBLEtBQUEsT0FBQTtvQkFDQSxLQUFBLE9BQUE7b0JBQ0EsS0FBQSxVQUFBOztnQkFFZixPQUFBOztZQVBhLE9BQUEsY0FBVztXQURMLFNBQUEsS0FBQSxXQUFBLEtBQUEsU0FBTTtPQUFYLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTzs7QUNBakIsSUFBVTtBQUFWLENBQUEsVUFBVSxTQUFPO0lBQUMsSUFBQTtJQUFBLENBQUEsVUFBQSxNQUFJO1FBQUMsSUFBQTtRQUFBLENBQUEsVUFBQSxVQUFTO1lBZ0I1QixJQUFLO1lBQUwsQ0FBQSxVQUFLLFlBQVU7Z0JBQUcsV0FBQSxXQUFB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b0JBRTFCLElBQUksY0FBYyxhQUFhLEtBQUs7b0JBRXBDLElBQUksQ0FBQyxhQUFhO3dCQUNkLEtBQUssS0FBSyxNQUFNO3dCQUNoQixPQUFPOztvQkFFWCxJQUFJLFlBQVksV0FBVyxHQUFHO3dCQUMxQixLQUFLLEtBQUssTUFBTTt3QkFDaEIsT0FBTzs7b0JBRVgsSUFBSSxZQUFZLFNBQVMsR0FBRzt3QkFDeEIsS0FBSyxLQUFLLE1BQU07d0JBQ2hCLE9BQU87O29CQUdYLE9BQU8sWUFBWTs7Ozs7O2dCQU9mLG1CQUFBLFVBQUEsMENBQVIsVUFBZ0QsMEJBQWdDO29CQUM1RSxJQUFJLENBQUM7d0JBQTBCLE9BQU87b0JBRXRDLElBQUksU0FBUyx5QkFBeUIsTUFBTSxLQUFLLEdBQUcsT0FBTyxNQUFNLEtBQUs7b0JBRXRFLE9BQU8sT0FBTyxRQUFRLE1BQU07O2dCQUlwQyxPQUFBOztZQTVaYSxTQUFBLHFCQUFrQjtZQThaL0IsUUFBUSxPQUFPLGtCQUFrQixDQUFDLFdBQVcsYUFBYTtpQkFLckQsUUFBUSxzQkFBc0I7V0FuZGhCLFdBQUEsS0FBQSxhQUFBLEtBQUEsV0FBUTtPQUFiLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTztBQ2laakIiLCJmaWxlIjoibmctaHR0cC13cmFwcGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibmFtZXNwYWNlIGJsdWVza3kuY29yZS5tb2RlbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIE1HQSA6IGV4cG9ydCBhbiBpbnRlcmZhY2UgdG9vID9cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIEFwaUNvbmZpZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgICAgIHB1YmxpYyBjb3JlQXBpVXJsOiBzdHJpbmcsXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiB0byBpbmplY3QgYXMgZ2VuZXJpYyBsaXN0IG9mIGN1c3RvbSBoZWFkZXJzIHRvIHBhc3MgdG8gJGh0dHAgc2VydmljZSA/XHJcbiAgICAgICAgICAgIHB1YmxpYyBqd3RUb2tlbjogc3RyaW5nLFxyXG4gICAgICAgICAgICBwdWJsaWMgY3VycmVudFVzZXJSb2xlOiBzdHJpbmdcclxuICAgICAgICApIHsgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIGJsdWVza3kuY29yZS5tb2RlbHMge1xyXG4gICAgZXhwb3J0IGNsYXNzIEZpbGVDb250ZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICAgICAgcHVibGljIG5hbWU6IHN0cmluZyxcclxuICAgICAgICAgICAgcHVibGljIHNpemU6IG51bWJlcixcclxuICAgICAgICAgICAgcHVibGljIHR5cGU6IHN0cmluZyxcclxuICAgICAgICAgICAgcHVibGljIGNvbnRlbnQ6IEFycmF5QnVmZmVyXHJcbiAgICAgICAgKSB7IH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBibHVlc2t5LmNvcmUuc2VydmljZXMge1xyXG5cclxuICAgIGltcG9ydCBBcGlDb25maWcgPSBibHVlc2t5LmNvcmUubW9kZWxzLkFwaUNvbmZpZztcclxuICAgIGltcG9ydCBGaWxlQ29udGVudCA9IGJsdWVza3kuY29yZS5tb2RlbHMuRmlsZUNvbnRlbnQ7XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBJSHR0cFdyYXBwZXJDb25maWcgZXh0ZW5kcyBuZy5JUmVxdWVzdFNob3J0Y3V0Q29uZmlnIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtYWluIEFQSSBlbmRwb2ludCB0byB1c2UgYXMgZGVmYXVsdCBvbmUgaWYgdXJsIGlzIG5vdCBmdWxsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFwaUVuZHBvaW50PzogYm9vbGVhbjtcclxuICAgICAgICBmaWxlPzogRmlsZSxcclxuICAgICAgICB1cGxvYWRJbkJhc2U2NEpzb24/OiBib29sZWFuO1xyXG4gICAgICAgIHVwbG9hZFByb2dyZXNzPzogKCkgPT4gYW55O1xyXG4gICAgICAgIGRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlcj86IGJvb2xlYW47XHJcbiAgICB9XHJcblxyXG4gICAgZW51bSBIdHRwTWV0aG9kIHsgR0VULCBQT1NULCBQVVQsIERFTEVURSB9O1xyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgSUh0dHBXcmFwcGVyU2VydmljZSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbCBzcnYtc2lkZSBjb25maWd1cmF0aW9uIG9mIG1haW4gQVBJIHByb3ZpZGVkIGJ5IHRoZSBkb21haW4gZnJvbSB3aGljaCB0aGlzIHNjcmlwdCB3YXMgbG9hZGVkLCBAIHRoZSB1cmwgJ0NvcmVBcGlBdXRoL0dldENvcmVBcGlDb25maWcnLlxyXG4gICAgICAgICAqIFRPRE8gTUdBIGZpeCBoYXJkIGNvZGVkIHBhdGguXHJcbiAgICAgICAgICogVGhpcyBjb25maWd1cmF0aW9uIGRhdGEgaXMgbG9hZGVkIHVwb24gaW5pdGlhbGl6YXRpb24gb2YgdGhpcyBzZXJ2aWNlICh0byBiZSB1c2VkIGFzIGEgc2luZ2xldG9uIGluIHRoZSBhcHApLiBBbGwgb3RoZXIgd2ViIGNhbGxzIGFyZSBibG9ja2VkIGFzIGxvbmcgYXMgdGhpcyBvbmUgaXMgbm90IGZpbmlzaGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFwaUNvbmZpZzogQXBpQ29uZmlnO1xyXG5cclxuICAgICAgICAvL1RPRE8gTUdBOiBmb3IgZm9sbG93aW5nIG1ldGhvZHMsIHJldHVybiBJUHJvbWlzZSBhbmQgYXNzdW1lIGFic3RyYWN0aW9uIG9yIGxldCBiZWxvdyBzZXJ2aWNlcyBoYW5kbGUgSUh0dHBQcm9taXNlcyA/XHJcblxyXG4gICAgICAgIGdldDxUPih1cmw6IHN0cmluZywgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHBvc3Q8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHB1dDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgLy9UT0RPIE1HQSBpbXByb3ZlIHR5cGluZyB3aXRoIGFuZ3VsYXItdXBsb2FkIHRzZCBldGNcclxuICAgICAgICB1cGxvYWQ8VD4odXJsOiBzdHJpbmcsIGZpbGU6IEZpbGUsIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+O1xyXG5cclxuICAgICAgICBnZXRGaWxlKHVybDogc3RyaW5nLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxGaWxlQ29udGVudD47XHJcblxyXG4gICAgICAgIGJ1aWxkVXJsRnJvbUNvbnRleHQodXJsSW5wdXQ6IHN0cmluZyk6IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRPRE8gTUdBIDogdGhpcyBtYXkgbm90IG5lZWQgdG8gYmUgYSBkZWRpY2F0ZWQgc2VydmljZSwgaXQgY2FuIGFsc28gYmUgaW5jb3Jwb3JhdGVkIGludG8gdGhlIGh0dHBJbnRlcmNlcHRvci4gRGVjaWRlIGJlc3QgYXBwcm9hY2ggZGVwZW5kaW5nIG9uIHBsYW5uZWQgdXNlLlxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgSHR0cFdyYXBwZXJTZXJ2aWNlIGltcGxlbWVudHMgSUh0dHBXcmFwcGVyU2VydmljZSB7XHJcblxyXG4gICAgICAgIC8vI3JlZ2lvbiBwcm9wZXJ0aWVzXHJcblxyXG4gICAgICAgIHByaXZhdGUgaW5pdFByb21pc2U6IG5nLklQcm9taXNlPGFueT47XHJcbiAgICAgICAgcHVibGljIGFwaUNvbmZpZzogQXBpQ29uZmlnO1xyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIGN0b3JcclxuXHJcbiAgICAgICAgLyogQG5nSW5qZWN0ICovXHJcbiAgICAgICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgICAgIHByaXZhdGUgJGh0dHA6IG5nLklIdHRwU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkd2luZG93OiBuZy5JV2luZG93U2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkbG9nOiBuZy5JTG9nU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkcTogbmcuSVFTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRsb2NhdGlvbjogbmcuSUxvY2F0aW9uU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSBVcGxvYWQ6IG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklVcGxvYWRTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIHRvYXN0ZXI6IG5ndG9hc3Rlci5JVG9hc3RlclNlcnZpY2VcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gaW5pdCBjb3JlIGFwaSBjb25maWcgZGF0YSBvbiBjdG9yXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBoYXJkIGNvZGVkIHBhdGggZm9yIENvcmVyQXBpQXV0aEN0cmwgdG8gaW5qZWN0XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLiRodHRwLmdldDxBcGlDb25maWc+KHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dCgnQ29yZUFwaUF1dGgvR2V0Q29yZUFwaUNvbmZpZycpKVxyXG4gICAgICAgICAgICAgICAgLnN1Y2Nlc3MoKGNvcmVBcGlDb25maWcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwaUNvbmZpZyA9IGNvcmVBcGlDb25maWc7XHJcbiAgICAgICAgICAgICAgICB9KS5lcnJvcigoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byByZXRyaWV2ZSBBUEkgY29uZmlnLiBBYm9ydGluZyBodHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHVibGljIG1ldGhvZHNcclxuXHJcbiAgICAgICAgZ2V0PFQ+KHVybDogc3RyaW5nLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuREVMRVRFLCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb3N0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHV0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5QVVQsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwbG9hZDxUPih1cmw6IHN0cmluZywgZmlsZTogRmlsZSwgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKCFmaWxlICYmICghY29uZmlnIHx8ICFjb25maWcuZmlsZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignQ2Fubm90IHN0YXJ0IHVwbG9hZCB3aXRoIG51bGwge2ZpbGV9IHBhcmFtZXRlci4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcbiAgICAgICAgICAgIGNvbmZpZy5maWxlID0gZmlsZSB8fCBjb25maWcuZmlsZTsgLy9UT0RPIE1HQSA6IGRvIG5vdCBleHBvc2UgZmlsZSBpbiBJSHR0cFdyYXBwZXJDb25maWcgP1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy51cGxvYWRJbkJhc2U2NEpzb24pIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSB0aGlzIGRlbGF5cyBuZXh0IGNhbGwgYW5kIHVwbG9hZCBpcyBub3QgZG9uZSBiZWZvcmUgYmFzZTY0IGVuY29kaW5nIGlzIGZpbmlzaGVkLCBldmVuIGlmIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCA/Pz9cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC5iYXNlNjREYXRhVXJsKGZpbGUpLnRoZW4oKGZpbGVCYXNlNjRVcmwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkLWNvZGVkIGtleSB0byBmZXRjaCBiYXNlNjQgZW5jb2RpbmcsIHRvIHBhcmFtZXRyaXplIHdpdGggc2VydmVyLXNpZGUgIVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVCYXNlNjRVcmwgPSBmaWxlQmFzZTY0VXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsIHBvc3QgaW4gY2FzZSBvZiBiYXNlNjQtZW5jb2RlZCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUZvcm1EYXRhTmFtZSA9ICdmaWxlJzsgLy8gZmlsZSBmb3JtRGF0YSBuYW1lICgnQ29udGVudC1EaXNwb3NpdGlvbicpLCBzZXJ2ZXIgc2lkZSByZXF1ZXN0IGZvcm0gbmFtZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBkbyBub3QgYmxvY2sgaWYgbm90IGNhbGwgdG8gaW50ZXJuYWwgQVBJIChpbml0Q2FsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBub3Qgc2FmZSBoYXJkIGNhc3RcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogYmVoYXZpb3IgZHVwbGljYXRpb24gd2l0aCB0aGlzLmFqYXgsIG5vdCBEUlksIHRvIGltcHJvdmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VcGxvYWQudXBsb2FkPFQ+KDxuZy5hbmd1bGFyRmlsZVVwbG9hZC5JRmlsZVVwbG9hZENvbmZpZ0ZpbGU+dGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW48VD4odGhpcy5vblN1Y2Nlc3MsIHRoaXMub25FcnJvciwgY29uZmlnLnVwbG9hZFByb2dyZXNzKSAvL1RPRE8gTUdBIDogdXBsb2FkUHJvZ3Jlc3MgY2FsbGJhY2sgb2sgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseSh0aGlzLmZpbmFsbHkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZG93bmxvYWQgYSBmaWxlIGluIHRoZSBmb3JtIG9mIGEgYnl0ZS1zdHJlYW0gZnJvbSBhbiBlbmRwb2ludCBhbmQgd3JhcCBpdCBpbnRvIGEgRmlsZUNvbnRlbnQgb2JqZWN0IHdpdGggbmFtZSwgdHlwZSAmIHNpemUgcHJvcGVydGllcyByZWFkIGZyb20gdGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBvZiB0aGUgc2VydmV1ci5cclxuICAgICAgICAgKiBJdCBpcyB0aGUgcmVzcG9uc2FiaWxpdHkgb2YgdGhlIGNvbnN1bWVyIHRvIGRvIHNvbWV0aGluZyB3aXRoIHRoZSB3cmFwcGVkIGJ5dGVBcnJheSAoZm9yIGV4YW1wbGUgZG93bmxvYWQgdGhlIGZpbGUsIG9yIHNob3cgaXQgaW5zaWRlIHRoZSB3ZWJQYWdlIGV0YykuXHJcbiAgICAgICAgICogQHBhcmFtIHVybFxyXG4gICAgICAgICAqIEBwYXJhbSBleHBlY3RlZE5hbWVcclxuICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRTaXplXHJcbiAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkVHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRGaWxlKHVybDogc3RyaW5nLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxGaWxlQ29udGVudD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZS50aGVuKCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWNhbGx5IGV4cGVjdCByYXcgcmVzcG9uc2UgdHlwZSwgb3RoZXJ3aXNlIGJ5dGUgc3RyZWFtIHJlc3BvbnNlcyBhcmUgY29ycnVwdGVkLlxyXG4gICAgICAgICAgICAgICAgYW5ndWxhckh0dHBDb25maWcucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuXHJcbiAgICAgICAgICAgICAgICAvL0V4cGVjdGVkIEFycmF5QnVmZmVyIHJlc3BvbnNlID0gYnl0ZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHA8QXJyYXlCdWZmZXI+KGFuZ3VsYXJIdHRwQ29uZmlnKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuPEZpbGVDb250ZW50PigoaHR0cFJlc3BvbnNlKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2JlbmVmaXQgZnJvbSBzdWNjZXNzQ2FsbGJhY2sgdmFsaWRhdGlvbiBiZWZvcmUgY29udGludWluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSB0aGlzLm9uU3VjY2VzczxBcnJheUJ1ZmZlcj4oaHR0cFJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHByb21pc2UgcmVqZWN0aW9uIHZzLiByZXR1cm4gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpIHJldHVybiBudWxsOyAvL3N0b3AgcHJvY2Vzc2luZyBpZiB1bmFibGUgdG8gcmV0cmlldmUgYnl0ZSBhcnJheVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGZpbGUgaW5mbyBmcm9tIHJlc3BvbnNlLWhlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVDb250ZW50OiBGaWxlQ29udGVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWRpc3Bvc2l0aW9uJykpIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBOdW1iZXIoaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtbGVuZ3RoJykpIHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm9uRXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RPRE8gTUdBIDogbWV0aG9kIHRvbyBzcGVjaWZpYyB0byBPTSBhcHBzIGNvbnRleHQsIG1heSBub3Qgd29yayBvdXRzaWRlIG9mIGl0LCB0byBhZGFwdCBmb3IgcHVibGljIHVzZSA/XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZXMgdG8gcGFyc2UgdGhlIGlucHV0IHVybCA6XHJcbiAgICAgICAgICogSWYgaXQgc2VlbXMgdG8gYmUgYSBmdWxsIFVSTCwgdGhlbiByZXR1cm4gYXMgaXMgKGNvbnNpZGVycyBpdCBleHRlcm5hbCBVcmwpIFxyXG4gICAgICAgICAqIE90aGVyd2lzZSwgdHJpZXMgdG8gZmluZCB0aGUgYmFzZSBVUkwgb2YgdGhlIGN1cnJlbnQgQmx1ZVNreSBhcHAgd2l0aCBvciB3aXRob3V0IHRoZSBpbmNsdWRlZCBDb250cm9sbGVyIGFuZCByZXR1cm5zIHRoZSBmdWxsIFVybCBcclxuICAgICAgICAgKiBAcGFyYW0gdXJsSW5wdXQgOiBUT0RPIE1HQTogZG9jdW1lbnQgZGlmZmVyZW50IGtpbmQgb2YgdXJscyB0aGF0IHRoaXMgbWV0aG9kIGNhbiB0YWtlIGFzIGlucHV0IChmdWxsLCBwYXJ0aWFsIGV0YylcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgYnVpbGRVcmxGcm9tQ29udGV4dCh1cmxJbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDEgLSBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMuXHJcbiAgICAgICAgICAgIGlmICh1cmxJbnB1dC5zbGljZSgwLCAnaHR0cDovLycubGVuZ3RoKSA9PT0gJ2h0dHA6Ly8nIHx8XHJcbiAgICAgICAgICAgICAgICB1cmxJbnB1dC5zbGljZSgwLCAnaHR0cHM6Ly8nLmxlbmd0aCkgPT09ICdodHRwczovLycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMiAtIE90aGVyd2lzZSwgdHJ5IHRvIGZpbmQgY29ycmVjdCBjb250cm9sbGVyXHJcblxyXG4gICAgICAgICAgICAvLyBCb29sZWFuIHVzZWQgdG8gdHJ5IHRvIGRldGVybWluZSBjb3JyZWN0IGZ1bGwgdXJsIChhZGQgLyBvciBub3QgYmVmb3JlIHRoZSB1cmwgZnJhZ21lbnQgZGVwZW5kaW5nIG9uIGlmIGZvdW5kIG9yIG5vdClcclxuICAgICAgICAgICAgdmFyIHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID0gdXJsSW5wdXQuc2xpY2UoMCwgJy8nLmxlbmd0aCkgPT09ICcvJztcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZ2V4IHRyeWluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGZyYWdtZW50IGNvbnRhaW5zIGEgLyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXIgc3VpdGVzID0+IGNvbnRyb2xsZXIgZ2l2ZW4gYXMgaW5wdXQsIG90aGVyd2lzZSwgYWN0aW9uIG9uIHNhbWUgY29udHJvbGxlciBleHBlY3RlZFxyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlcklzUHJlc2VudFJlZ2V4ID0gL1xcdytcXC9cXHcrLztcclxuXHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSB0aGlzLmdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlVXJsICsgKHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID8gdXJsSW5wdXQgOiAoJy8nICsgdXJsSW5wdXQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBtZXRob2RzXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFV0aWxpdHkgbWV0aG9kLlxyXG4gICAgICAgICAqIE1haW4gY2FsbGVyIHRoYXQgYWxsIHdyYXBwZXIgY2FsbHMgKGdldCwgZGVsZXRlLCBwb3N0LCBwdXQpIG11c3QgdXNlIHRvIHNoYXJlIGNvbW1vbiBiZWhhdmlvci5cclxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBhamF4PFQ+KG1ldGhvZDogSHR0cE1ldGhvZCwgdXJsOiBzdHJpbmcsIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1ha2Ugc3VyZSBpbml0UHJvbWlzZSByZXNvbHZlIGF1dG9tYXRpY2FsbHkgd2l0aG91dCBvdmVyaGVhZCBvbmNlIGZpcnN0IGNhbGwgc3VjZXNzZnVsbC5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgKGluaXRDYWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmd1bGFySHR0cENvbmZpZyA9IHRoaXMuY29uZmlndXJlSHR0cENhbGwobWV0aG9kLCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaHR0cDxUPihhbmd1bGFySHR0cENvbmZpZylcclxuICAgICAgICAgICAgICAgICAgICAudGhlbjxUPih0aGlzLm9uU3VjY2VzcywgdGhpcy5vbkVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KHRoaXMuZmluYWxseSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBQcmVwYXJlcyBhIHtAbGluayBuZyMkaHR0cCNjb25maWcgY29uZmlnfSBvYmplY3QgZm9yICRodHRwIGNhbGwuXHJcbiAgICAgICAgKiBUaGUgb3BlcmF0aW9ucyBpbmNsdWRlIHNldHRpbmcgZGVmYXVsdCB2YWx1ZXMgd2hlbiBub3QgcHJvdmlkZWQsIGFuZCBzZXR0aW5nIGh0dHAgaGVhZGVycyBpZiBuZWVkZWQgZm9yIDpcclxuICAgICAgICAqICAtIEFqYXggY2FsbHNcclxuICAgICAgICAqICAtIEF1dGhvcml6YXRpb24gdG9rZW5cclxuICAgICAgICAqICAtIEN1cnJlbnQgVXNlclJvbGUuICAgXHJcbiAgICAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICAgICogQHJldHVybnMge25nLiRodHRwLmNvbmZpZ30gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHJlYWR5IHRvIGJlIGluamVjdGVkIGludG8gYSAkaHR0cCBjYWxsLiBcclxuICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgY29uZmlndXJlSHR0cENhbGwgPSAobWV0aG9kOiBIdHRwTWV0aG9kLCB1cmw6IHN0cmluZywgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVJlcXVlc3RDb25maWcgPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKCF1cmwgfHwgbWV0aG9kID09PSBudWxsIHx8IG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VSTCAmIE1FVEhPRCBwYXJhbWV0ZXJzIGFyZSBuZWNlc3NhcnkgZm9yIGh0dHBXcmFwcGVyIGNhbGxzLiBBYm9ydGluZy4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL0luaXQgY29uZmlnIGV2ZW4gaWYgbm90IHByb3ZpZGVkXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY2FzdCBpcyBub3Qgc2FmZSwgd2UgbWF5IGZvcmdldCB0byBzZXQgdXJsICYgbWV0aG9kIHBhcmFtZXRlcnMuIFRPRklYLlxyXG4gICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGdldCBhbGwgbm9uLWZpbHRlcmVkIHBhcmFtZXRlcnMgJiBrZWVwIHRoZW0gZm9yIHRoaXMgbmV3IG9iamVjdC5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZ0Z1bGwgPSA8bmcuSVJlcXVlc3RDb25maWc+Y29uZmlnO1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogc3VwcG9ydCBtYXBwaW5nIGJldHdlZW4gdXBsb2FkICYgcG9zdCBoZXJlID9cclxuICAgICAgICAgICAgY29uZmlnRnVsbC5tZXRob2QgPSBIdHRwTWV0aG9kW21ldGhvZF07XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmFwaUVuZHBvaW50ICYmICghdGhpcy5hcGlDb25maWcgfHxcclxuICAgICAgICAgICAgICAgICF0aGlzLmFwaUNvbmZpZy5qd3RUb2tlbiB8fFxyXG4gICAgICAgICAgICAgICAgIXRoaXMuYXBpQ29uZmlnLmN1cnJlbnRVc2VyUm9sZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0ludGVybmFsRXJyb3JdIFske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBjb3JlQXBpIGNhbGwgaW50ZW5kZWQgd2l0aG91dCBuZWNlc3NhcnkgY2FwaSBjcmVkZW50aWFscy4gQWJvcnRpbmcuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5hcGlFbmRwb2ludCkgeyAvLyBpZiBub3Qgc2V0LCBldmFsdWF0ZXMgdG8gZmFsc2VcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwudXJsID0gdGhpcy5idWlsZFVybEZyb21Db250ZXh0KHVybCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogY29yZSBhcGkgZW5kcG9pbnQgJ2FwaS8nIGhhcmRjb2RlZCwgdG8gcHV0IGluIGNvbmZpZ0Z1bGwgISBzaG91bGQgbm90IGtub3cgdGhhdCBoZXJlLlxyXG4gICAgICAgICAgICAgICAgY29uZmlnRnVsbC51cmwgPSB0aGlzLmFwaUNvbmZpZy5jb3JlQXBpVXJsICsgJ2FwaS8nICsgdXJsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwaUNvbmZpZy5qd3RUb2tlbiAmJiB0aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlcnMsIG5vdCBnb29kLCB0byBpbmplY3RcclxuICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ09BLVVzZXJSb2xlJ10gPSB0aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyB0aGlzLmFwaUNvbmZpZy5qd3RUb2tlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKSAvLyBpZiBub3Qgc2V0LCBldmFsdWF0ZXMgdG8gZmFsc2VcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FIHNwZWNpZmljIGNvZGUsIHRvIHJlbW92ZVxyXG4gICAgICAgICAgICBpZiAoKDxhbnk+dGhpcy4kd2luZG93KS5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cclxuICAgICAgICAgICAgICAgICg8YW55PnRoaXMuJHdpbmRvdykucHJldmVudEJsb2NrVUkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ0Z1bGw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3VjY2VzcyBoYW5kbGVyLlxyXG4gICAgICAgICAqIENhcHR1cmVzIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIGF0IHRoZSBtb21lbnQgb2YgaXRzIGRlY2xhcmF0aW9uICYgcmV0dXJuIHRoZSByZWFsIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHVwb24gcHJvbWlzZSBjb21wbGV0aW9uLlxyXG4gICAgICAgICAqIElucHV0IHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICogIC0gY2FsbGluZ0NvbmZpZzogY29uZmlndXJhdGlvbiB1c2VkIHRvIG1ha2UgdGhlIGFqYXggY2FsbCwgaW4gY2FzZSB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBudWxsL2VtcHR5IGFuZCBkb2Vzbid0IGNvbnRhaW4gbmVjZXNzYXJ5IGRhdGEgZm9yIGRlYnVnZ2luZy5cclxuICAgICAgICAgKiAgLSBnZXRDb21wbGV0ZVJlc3BvbnNlT2JqZWN0OiBmbGFnIGluZGljYXRpb24gaWYgd2UgbXVzdCByZXR1cm4gdGhlIGZ1bGwgcmVzcG9uc2Ugb2JqZWN0IGFsb25nIHdpdGggaGVhZGVycyBhbmQgc3RhdHVzIG9yIG9ubHkgdGhlIGlubmVyIGRhdGEuIEJ5IGRlZmF1bHQgJiBpZiBub3Qgc3BlY2lmaWVkLCBvbmx5IHJldHVybnMgaW5uZXIgZGF0YS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIG9uU3VjY2VzcyA9IDxUPihodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8VD4pOiBUID0+IHtcclxuXHJcbiAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0hUVFAgbm8tcmVzcG9uc2VdIFVuZXhwZWN0ZWQgJGh0dHAgZXJyb3IsIG5vIHJlc3BvbnNlIHByb21pc2UgcmV0dXJuZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgYmVoYXZpb3InLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtdWx0aS10eXBlIHJldHVybiBpbiBjYXNlIG9mIHJlamVjdGlvbiBvciBkbyBzb21ldGhpbmcgZWxzZSA/IHRoaXMgbWV0aG9kIGlzIGN1cnJlbnRseSB1c2VkIHN5bmNocm9ub3VzbHkgd2l0aG91dCBwcm9taXNlIHdhaXRpbmcuXHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiB0aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7IC8vIFJlamVjdCBwcm9taXNlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB3aGVuIEFQSSBpcyBmaXhlZC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3NDY4OTQvd2hhdC1pcy10aGUtcHJvcGVyLXJlc3QtcmVzcG9uc2UtY29kZS1mb3ItYS12YWxpZC1yZXF1ZXN0LWJ1dC1hbi1lbXB0eS1kYXRhXHJcbiAgICAgICAgICAgIC8vaWYgKChwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gbnVsbCB8fCBwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gdW5kZWZpbmVkKSAmJiBwcm9taXNlQ2FsbGJhY2suc3RhdHVzICE9PSAyMDQpIHtcclxuICAgICAgICAgICAgLy8gICAgdGhpcy4kbG9nLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSBidXQgbm9uZSBmb3VuZC4nKTtcclxuICAgICAgICAgICAgLy8gICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UnLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XHJcbiAgICAgICAgICAgIC8vICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChwcm9taXNlQ2FsbGJhY2spOyAvLyBSZWplY3QgcHJvbWlzZSBpZiBub3Qgd2VsbC1mb3JtZWQgZGF0YVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogc2FtZSBiZWhhdmlvciBhbHNvIG9uIGEgR0VUIHJlcXVlc3QgPyBpZiByZXF1ZXN0IGlzIEdFVCBhbmQgcmVzcG9uc2UgaXMgMjAwIHdpdGggbm8gZGF0YSwgcmV0dXJuIGVycm9yID8gKHBhc3MgaW4gcGFyYW1ldGVyIHJlcXVlc3QgY29udGV4dCB0byBsb2cgdGhpcyBlcnJvcikuXHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxyXG4gICAgICAgICAgICB0aGlzLiRsb2cuZGVidWcoYFtIVFRQICR7aHR0cFByb21pc2UuY29uZmlnLm1ldGhvZH1dIFske2h0dHBQcm9taXNlLmNvbmZpZy51cmx9XWAsIGh0dHBQcm9taXNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBkYXRhIGV4cGVjdGVkIGZvciBjYWxsZXJcclxuICAgICAgICAgICAgcmV0dXJuIGh0dHBQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcnJvciBoYW5kbGVyXHJcbiAgICAgICAgICogQHBhcmFtIGh0dHBQcm9taXNlIFxyXG4gICAgICAgICAqIEByZXR1cm5zIHt9IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgb25FcnJvciA9IChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8YW55Pik6IG5nLklQcm9taXNlPG5nLklIdHRwUHJvbWlzZUNhbGxiYWNrQXJnPGFueT4+ID0+IHsgLy8gZG8gc29tZXRoaW5nIG9uIGVycm9yXHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzdXBwb3NlIGluIGNhc2Ugb2Ygbm8gcmVzcG9uc2UgdGhhdCB0aGUgc3J2IGRpZG4ndCBzZW5kIGFueSByZXNwb25zZS5cclxuICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1heSBhbHNvIGJlIGEgZmF1bHQgaW4gaW50ZXJuYWwgJGh0dHAgLyBhamF4IGNsaWVudCBzaWRlIGxpYiwgdG8gZGlzdGluZ3Vpc2guXHJcbiAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UgfHwgIWh0dHBQcm9taXNlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEgPSAnU2VydmVyIG5vdCByZXNwb25kaW5nJztcclxuICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLnN0YXR1cyA9IDUwMztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaHR0cFByb21pc2UuaGVhZGVycygnQ29udGVudC1UeXBlJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlOiBzdHJpbmcgPSBcIlwiOyAvL2RlZmF1bHQgbWVzc2FnZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBlcnJvciBoYW5kbGluZyBtb3JlIGdlbmVyaWNhbGx5IGJhc2VkIG9uIGlucHV0IGVycm9yIG1lc3NhZ2UgY29udHJhY3QgaW5zdGVhZCBvZiBleHBlY3Rpbmcgc3BlY2lmaWMgZXJyb3Igc3RyY3R1cmUuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiAocmVzcG9uc2UuZGF0YS5Nb2RlbFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAvL1RPRE8gTUdBIDogaGFuZGxlIHRoaXMgd2hlbiB3ZWxsIGZvcm1hdHRlZCBzZXJ2ZXItc2lkZVxyXG4gICAgICAgICAgICAgICAgLy99IGVsc2VcclxuICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UgJiYgYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtb3JlIHJlc3BvbnNlIGNvZGVzIGdyYWNlZnVsbHkuXHJcbiAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2Uuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnTm90IEZvdW5kJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci5lcnJvcignU2VydmVyIHJlc3BvbnNlIGVycm9yJywgbWVzc2FnZSArICdcXG4gU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci5lcnJvcignSW50ZXJuYWwgc2VydmVyIGVycm9yJywgJ1N0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XHJcbiAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0hUVFAgJHtodHRwUHJvbWlzZS5jb25maWcubWV0aG9kfV0gWyR7aHR0cFByb21pc2UuY29uZmlnLnVybH1dYCwgaHR0cFByb21pc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVjb3ZlciBmcm9tIGVycm9yLCBzbyB3ZSBwcm9wYWdhdGUgaXQgOiBiZWxvdyBoYW5kbGVycyBoYXZlIHRoZSBjaG9pY2Ugb2YgcmVhZGluZyB0aGUgZXJyb3Igd2l0aCBhbiBlcnJvciBoYW5kbGVyIG9yIG5vdC4gU2VlICRxIHByb21pc2VzIGJlaGF2aW9yIGhlcmUgOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3FcclxuICAgICAgICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBkZXNpcmVkIHNvIHRoYXQgd2Ugc2hvdyBlcnJvciBpbnNpZGUgc3BlY2lmaWMgc2VydmVyIGNvbW11bmljYXRpb24gbW9kYWxzIGF0IHNwZWNpZmljIHBsYWNlcyBpbiB0aGUgYXBwLCBvdGhlcndpc2Ugc2hvdyBhIGdsb2JhbCBhbGVydCBtZXNzYWdlLCBvciBldmVuIGRvIG5vdCBzaG93IGFueXRoaW5nIGlmIG5vdCBuZWNlc3NhcnkgKGRvIG5vdCBhZCBhbiBlcnJvciBoYW5kbGVyIGluIGJlbG93IGhhbmRsZXJzIG9mIHRoaXMgcHJvbWlzZSkuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhamF4IGNhbGwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBzdWNjZXNzIG9yIGZhaWx1cmUuXHJcbiAgICAgICAgICogQHBhcmFtIHJlc3BvbnNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBmaW5hbGx5ID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBPRS1zcGVjaWZpYyBjb2RlXHJcbiAgICAgICAgICAgIGlmICgoPGFueT50aGlzLiR3aW5kb3cpLmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xyXG4gICAgICAgICAgICAgICAgKDxhbnk+dGhpcy4kd2luZG93KS5wcmV2ZW50QmxvY2tVSSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETyBNR0EgOiB1c2luZyBtZXRob2QgZnJvbSBMYXlvdXQuanMgOiB0byBkb2N1bWVudCB0byBub3QgaGFuZGxlIGR1cGxpY2F0ZSBjb2RlICEhXHJcbiAgICAgICAgLy9UT0RPIE1HQTogdW5yb2J1c3QsIG5lZWRzIHNvbGlkIHJlZmFjdG8gdG8gbWFrZSBpdCBtb3JlIGdlbmVyaWMgd2hlbiBvbiBvcmlnaW4gZG9tYWluICFcclxuICAgICAgICBwcml2YXRlIGdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyOiBib29sZWFuKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsT21BcHBzUmVnZXggPSAvKFxcL1xcdytcXC9cXChTXFwoXFx3K1xcKVxcKSlcXC9cXHcqLztcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxBc3BBcHBzUmVnZXggPSAvKFxcL1xcdyspXFwvXFx3Ki87XHJcblxyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc01hdGNoZXMgPSBiYXNlVXJsT21BcHBzUmVnZXguZXhlYyh1cmwpO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNNYXRjaGVzID0gYmFzZVVybEFzcEFwcHNSZWdleC5leGVjKHVybCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTogc3RyaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmw6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyAyIG1hdGNoZXMgPSByZWdleCBtYXRjaGVzICsgdGhlIGNhcHR1cmluZyBncm91cFxyXG4gICAgICAgICAgICBpZiAoYmFzZVVybE9tQXBwc01hdGNoZXMgJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xyXG5cclxuICAgICAgICAgICAgICAgIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxzZSBpZiAoYmFzZVVybEFzcEFwcHNNYXRjaGVzICYmIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcy5sZW5ndGggJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsQXNwQXBwc01hdGNoZXNbMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgJiYgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFzZVVybCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETyBNR0E6IE9NLXNwZWNpZmljIEFTUCBNVkMgY29kZSwgbm90IHVzZWQgQVRNLCB0byByZW1vdmVcclxuICAgICAgICBwcml2YXRlIGdldEN1cnJlbnRTZXNzaW9uSUQoKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWdpYyByZWdleHAgdG8gZmV0Y2ggU2Vzc2lvbklEIGluIFVSTCwgdG8gc3RvcmUgZWxzZXdoZXJlICFcclxuICAgICAgICAgICAgdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvW1xcdy5dK1xcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XHJcbiAgICAgICAgICAgIC8vdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvT3JkZXJFbnRyeVxcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHVwZGF0ZSByZWdleHAgdG8gdGhlIG9uZSBiZWxvd1xyXG4gICAgICAgICAgICAvL3ZhciBiYXNlVXJsUmVnZXggPSAvKGh0dHBzOlxcL1xcL1tcXHcuLV0rXFwvW1xcdy4tXStcXC9cXChTXFwoXFx3K1xcKVxcKVxcLylcXHcrLztcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuJGxvY2F0aW9uLmFic1VybCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlZ2V4cEFycmF5ID0gc2Vzc2lvblJlZ2V4LmV4ZWMocGF0aCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byByZWNvZ25pemVkIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwgbG9jYXRpb24gdG8gcmV0cmlldmUgc2Vzc2lvbklELicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIGZpbmQgc2Vzc2lvbklEIGluIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVG9vIG1hbnkgbWF0Y2hlcyBmb3VuZCBmb3IgdGhlIHNlc3Npb25JRCBzZWFyY2ggaW4gdGhlIGN1cnJlbnQgdXJsLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVnZXhwQXJyYXlbMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmltIHRoZSBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciB0byByZXR1cm4gb25seSB0aGUgZmlsZW5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uKGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcjogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICAgICAgaWYgKCFjb250ZW50RGlzcG9zaXRpb25IZWFkZXIpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlci5zcGxpdCgnOycpWzFdLnRyaW0oKS5zcGxpdCgnPScpWzFdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cIi9nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuICAgIH1cclxuXHJcbiAgICBhbmd1bGFyLm1vZHVsZSgnbmcuaHR0cFdyYXBwZXInLCBbJ3RvYXN0ZXInLCAnbmdBbmltYXRlJywgJ25nRmlsZVVwbG9hZCddKVxyXG4gICAgICAgIC8vIGRvbmUgaW4gY29uZmlndXJlSHR0cENhbGwgbWV0aG9kLlxyXG4gICAgICAgIC8vLmNvbmZpZyhbJyRodHRwUHJvdmlkZXInLCAoJGh0dHBQcm92aWRlcjogbmcuSUh0dHBQcm92aWRlcikgPT4ge1xyXG4gICAgICAgIC8vICAgICRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XHJcbiAgICAgICAgLy99XSlcclxuICAgICAgICAuc2VydmljZSgnaHR0cFdyYXBwZXJTZXJ2aWNlJywgSHR0cFdyYXBwZXJTZXJ2aWNlKTtcclxufSIsInZhciBibHVlc2t5O1xuKGZ1bmN0aW9uIChibHVlc2t5KSB7XG4gICAgdmFyIGNvcmU7XG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgIHZhciBtb2RlbHM7XG4gICAgICAgIChmdW5jdGlvbiAobW9kZWxzKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE8gTUdBIDogZXhwb3J0IGFuIGludGVyZmFjZSB0b28gP1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgQXBpQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBBcGlDb25maWcoY29yZUFwaVVybCwgXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiB0byBpbmplY3QgYXMgZ2VuZXJpYyBsaXN0IG9mIGN1c3RvbSBoZWFkZXJzIHRvIHBhc3MgdG8gJGh0dHAgc2VydmljZSA/XG4gICAgICAgICAgICAgICAgICAgIGp3dFRva2VuLCBjdXJyZW50VXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3JlQXBpVXJsID0gY29yZUFwaVVybDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qd3RUb2tlbiA9IGp3dFRva2VuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRVc2VyUm9sZSA9IGN1cnJlbnRVc2VyUm9sZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFwaUNvbmZpZztcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBtb2RlbHMuQXBpQ29uZmlnID0gQXBpQ29uZmlnO1xuICAgICAgICB9KShtb2RlbHMgPSBjb3JlLm1vZGVscyB8fCAoY29yZS5tb2RlbHMgPSB7fSkpO1xuICAgIH0pKGNvcmUgPSBibHVlc2t5LmNvcmUgfHwgKGJsdWVza3kuY29yZSA9IHt9KSk7XG59KShibHVlc2t5IHx8IChibHVlc2t5ID0ge30pKTtcblxudmFyIGJsdWVza3k7XG4oZnVuY3Rpb24gKGJsdWVza3kpIHtcbiAgICB2YXIgY29yZTtcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgdmFyIG1vZGVscztcbiAgICAgICAgKGZ1bmN0aW9uIChtb2RlbHMpIHtcbiAgICAgICAgICAgIHZhciBGaWxlQ29udGVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRmlsZUNvbnRlbnQobmFtZSwgc2l6ZSwgdHlwZSwgY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gRmlsZUNvbnRlbnQ7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgbW9kZWxzLkZpbGVDb250ZW50ID0gRmlsZUNvbnRlbnQ7XG4gICAgICAgIH0pKG1vZGVscyA9IGNvcmUubW9kZWxzIHx8IChjb3JlLm1vZGVscyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuXG52YXIgYmx1ZXNreTtcbihmdW5jdGlvbiAoYmx1ZXNreSkge1xuICAgIHZhciBjb3JlO1xuICAgIChmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICB2YXIgc2VydmljZXM7XG4gICAgICAgIChmdW5jdGlvbiAoc2VydmljZXMpIHtcbiAgICAgICAgICAgIHZhciBIdHRwTWV0aG9kO1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChIdHRwTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiR0VUXCJdID0gMF0gPSBcIkdFVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBPU1RcIl0gPSAxXSA9IFwiUE9TVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIlBVVFwiXSA9IDJdID0gXCJQVVRcIjtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJERUxFVEVcIl0gPSAzXSA9IFwiREVMRVRFXCI7XG4gICAgICAgICAgICB9KShIdHRwTWV0aG9kIHx8IChIdHRwTWV0aG9kID0ge30pKTtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVE9ETyBNR0EgOiB0aGlzIG1heSBub3QgbmVlZCB0byBiZSBhIGRlZGljYXRlZCBzZXJ2aWNlLCBpdCBjYW4gYWxzbyBiZSBpbmNvcnBvcmF0ZWQgaW50byB0aGUgaHR0cEludGVyY2VwdG9yLiBEZWNpZGUgYmVzdCBhcHByb2FjaCBkZXBlbmRpbmcgb24gcGxhbm5lZCB1c2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBIdHRwV3JhcHBlclNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBjdG9yXG4gICAgICAgICAgICAgICAgLyogQG5nSW5qZWN0ICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSHR0cFdyYXBwZXJTZXJ2aWNlKCRodHRwLCAkd2luZG93LCAkbG9nLCAkcSwgJGxvY2F0aW9uLCBVcGxvYWQsIHRvYXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kaHR0cCA9ICRodHRwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aW5kb3cgPSAkd2luZG93O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cgPSAkbG9nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRxID0gJHE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvY2F0aW9uID0gJGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlVwbG9hZCA9IFVwbG9hZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2FzdGVyID0gdG9hc3RlcjtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICogUHJlcGFyZXMgYSB7QGxpbmsgbmcjJGh0dHAjY29uZmlnIGNvbmZpZ30gb2JqZWN0IGZvciAkaHR0cCBjYWxsLlxuICAgICAgICAgICAgICAgICAgICAqIFRoZSBvcGVyYXRpb25zIGluY2x1ZGUgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyB3aGVuIG5vdCBwcm92aWRlZCwgYW5kIHNldHRpbmcgaHR0cCBoZWFkZXJzIGlmIG5lZWRlZCBmb3IgOlxuICAgICAgICAgICAgICAgICAgICAqICAtIEFqYXggY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgKiAgLSBBdXRob3JpemF0aW9uIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICogIC0gQ3VycmVudCBVc2VyUm9sZS5cbiAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtuZy4kaHR0cC5jb25maWd9IHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCByZWFkeSB0byBiZSBpbmplY3RlZCBpbnRvIGEgJGh0dHAgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmVIdHRwQ2FsbCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVybCB8fCBtZXRob2QgPT09IG51bGwgfHwgbWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKCdVUkwgJiBNRVRIT0QgcGFyYW1ldGVycyBhcmUgbmVjZXNzYXJ5IGZvciBodHRwV3JhcHBlciBjYWxscy4gQWJvcnRpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0luaXQgY29uZmlnIGV2ZW4gaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNhc3QgaXMgbm90IHNhZmUsIHdlIG1heSBmb3JnZXQgdG8gc2V0IHVybCAmIG1ldGhvZCBwYXJhbWV0ZXJzLiBUT0ZJWC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZ2V0IGFsbCBub24tZmlsdGVyZWQgcGFyYW1ldGVycyAmIGtlZXAgdGhlbSBmb3IgdGhpcyBuZXcgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpZ0Z1bGwgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzdXBwb3J0IG1hcHBpbmcgYmV0d2VlbiB1cGxvYWQgJiBwb3N0IGhlcmUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5tZXRob2QgPSBIdHRwTWV0aG9kW21ldGhvZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmFwaUVuZHBvaW50ICYmICghX3RoaXMuYXBpQ29uZmlnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLmFwaUNvbmZpZy5qd3RUb2tlbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFfdGhpcy5hcGlDb25maWcuY3VycmVudFVzZXJSb2xlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbSW50ZXJuYWxFcnJvcl0gW1wiICsgY29uZmlnRnVsbC5tZXRob2QgKyBcIiAvIFwiICsgdXJsICsgXCJdIC0gY29yZUFwaSBjYWxsIGludGVuZGVkIHdpdGhvdXQgbmVjZXNzYXJ5IGNhcGkgY3JlZGVudGlhbHMuIEFib3J0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuYXBpRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLnVybCA9IF90aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBjb3JlIGFwaSBlbmRwb2ludCAnYXBpLycgaGFyZGNvZGVkLCB0byBwdXQgaW4gY29uZmlnRnVsbCAhIHNob3VsZCBub3Qga25vdyB0aGF0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC51cmwgPSBfdGhpcy5hcGlDb25maWcuY29yZUFwaVVybCArICdhcGkvJyArIHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXBpQ29uZmlnLmp3dFRva2VuICYmIF90aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZCBjb2RlZCBoZWFkZXJzLCBub3QgZ29vZCwgdG8gaW5qZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snT0EtVXNlclJvbGUnXSA9IF90aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgX3RoaXMuYXBpQ29uZmlnLmp3dFRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPRSBzcGVjaWZpYyBjb2RlLCB0byByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy4kd2luZG93LmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kd2luZG93LnByZXZlbnRCbG9ja1VJID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWdGdWxsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogU3VjY2VzcyBoYW5kbGVyLlxuICAgICAgICAgICAgICAgICAgICAgKiBDYXB0dXJlcyB0aGUgaW5wdXQgcGFyYW1ldGVycyBhdCB0aGUgbW9tZW50IG9mIGl0cyBkZWNsYXJhdGlvbiAmIHJldHVybiB0aGUgcmVhbCBoYW5kbGVyIHRvIGJlIGNhbGxlZCB1cG9uIHByb21pc2UgY29tcGxldGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICogSW5wdXQgcGFyYW1ldGVyczpcbiAgICAgICAgICAgICAgICAgICAgICogIC0gY2FsbGluZ0NvbmZpZzogY29uZmlndXJhdGlvbiB1c2VkIHRvIG1ha2UgdGhlIGFqYXggY2FsbCwgaW4gY2FzZSB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBudWxsL2VtcHR5IGFuZCBkb2Vzbid0IGNvbnRhaW4gbmVjZXNzYXJ5IGRhdGEgZm9yIGRlYnVnZ2luZy5cbiAgICAgICAgICAgICAgICAgICAgICogIC0gZ2V0Q29tcGxldGVSZXNwb25zZU9iamVjdDogZmxhZyBpbmRpY2F0aW9uIGlmIHdlIG11c3QgcmV0dXJuIHRoZSBmdWxsIHJlc3BvbnNlIG9iamVjdCBhbG9uZyB3aXRoIGhlYWRlcnMgYW5kIHN0YXR1cyBvciBvbmx5IHRoZSBpbm5lciBkYXRhLiBCeSBkZWZhdWx0ICYgaWYgbm90IHNwZWNpZmllZCwgb25seSByZXR1cm5zIGlubmVyIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2VzcyA9IGZ1bmN0aW9uIChodHRwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbSFRUUCBuby1yZXNwb25zZV0gVW5leHBlY3RlZCAkaHR0cCBlcnJvciwgbm8gcmVzcG9uc2UgcHJvbWlzZSByZXR1cm5lZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci5lcnJvcignVW5leHBlY3RlZCBiZWhhdmlvcicsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB3aGVuIEFQSSBpcyBmaXhlZC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3NDY4OTQvd2hhdC1pcy10aGUtcHJvcGVyLXJlc3QtcmVzcG9uc2UtY29kZS1mb3ItYS12YWxpZC1yZXF1ZXN0LWJ1dC1hbi1lbXB0eS1kYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmICgocHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IG51bGwgfHwgcHJvbWlzZUNhbGxiYWNrLmRhdGEgPT09IHVuZGVmaW5lZCkgJiYgcHJvbWlzZUNhbGxiYWNrLnN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBleHBlY3RlZCByZXNwb25zZSBkYXRhIGJ1dCBub25lIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UnLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICByZXR1cm4gdGhpcy4kcS5yZWplY3QocHJvbWlzZUNhbGxiYWNrKTsgLy8gUmVqZWN0IHByb21pc2UgaWYgbm90IHdlbGwtZm9ybWVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogc2FtZSBiZWhhdmlvciBhbHNvIG9uIGEgR0VUIHJlcXVlc3QgPyBpZiByZXF1ZXN0IGlzIEdFVCBhbmQgcmVzcG9uc2UgaXMgMjAwIHdpdGggbm8gZGF0YSwgcmV0dXJuIGVycm9yID8gKHBhc3MgaW4gcGFyYW1ldGVyIHJlcXVlc3QgY29udGV4dCB0byBsb2cgdGhpcyBlcnJvcikuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5kZWJ1ZyhcIltIVFRQIFwiICsgaHR0cFByb21pc2UuY29uZmlnLm1ldGhvZCArIFwiXSBbXCIgKyBodHRwUHJvbWlzZS5jb25maWcudXJsICsgXCJdXCIsIGh0dHBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBkYXRhIGV4cGVjdGVkIGZvciBjYWxsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBodHRwUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogRXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaHR0cFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge31cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvciA9IGZ1bmN0aW9uIChodHRwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc3VwcG9zZSBpbiBjYXNlIG9mIG5vIHJlc3BvbnNlIHRoYXQgdGhlIHNydiBkaWRuJ3Qgc2VuZCBhbnkgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQTogbWF5IGFsc28gYmUgYSBmYXVsdCBpbiBpbnRlcm5hbCAkaHR0cCAvIGFqYXggY2xpZW50IHNpZGUgbGliLCB0byBkaXN0aW5ndWlzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UgfHwgIWh0dHBQcm9taXNlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUHJvbWlzZS5kYXRhID0gJ1NlcnZlciBub3QgcmVzcG9uZGluZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cFByb21pc2Uuc3RhdHVzID0gNTAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaHR0cFByb21pc2UuaGVhZGVycygnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJcIjsgLy9kZWZhdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgZXJyb3IgaGFuZGxpbmcgbW9yZSBnZW5lcmljYWxseSBiYXNlZCBvbiBpbnB1dCBlcnJvciBtZXNzYWdlIGNvbnRyYWN0IGluc3RlYWQgb2YgZXhwZWN0aW5nIHNwZWNpZmljIGVycm9yIHN0cmN0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKHJlc3BvbnNlLmRhdGEuTW9kZWxTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC8vVE9ETyBNR0EgOiBoYW5kbGUgdGhpcyB3aGVuIHdlbGwgZm9ybWF0dGVkIHNlcnZlci1zaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy99IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlICYmIGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaHR0cFByb21pc2UuZGF0YS5NZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKGh0dHBQcm9taXNlLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYW5kbGUgbW9yZSByZXNwb25zZSBjb2RlcyBncmFjZWZ1bGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLndhcm5pbmcoJ05vdCBGb3VuZCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudG9hc3Rlci5lcnJvcignU2VydmVyIHJlc3BvbnNlIGVycm9yJywgbWVzc2FnZSArICdcXG4gU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLmVycm9yKCdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InLCAnU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmVycm9yKFwiW0hUVFAgXCIgKyBodHRwUHJvbWlzZS5jb25maWcubWV0aG9kICsgXCJdIFtcIiArIGh0dHBQcm9taXNlLmNvbmZpZy51cmwgKyBcIl1cIiwgaHR0cFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVjb3ZlciBmcm9tIGVycm9yLCBzbyB3ZSBwcm9wYWdhdGUgaXQgOiBiZWxvdyBoYW5kbGVycyBoYXZlIHRoZSBjaG9pY2Ugb2YgcmVhZGluZyB0aGUgZXJyb3Igd2l0aCBhbiBlcnJvciBoYW5kbGVyIG9yIG5vdC4gU2VlICRxIHByb21pc2VzIGJlaGF2aW9yIGhlcmUgOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3FcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgZGVzaXJlZCBzbyB0aGF0IHdlIHNob3cgZXJyb3IgaW5zaWRlIHNwZWNpZmljIHNlcnZlciBjb21tdW5pY2F0aW9uIG1vZGFscyBhdCBzcGVjaWZpYyBwbGFjZXMgaW4gdGhlIGFwcCwgb3RoZXJ3aXNlIHNob3cgYSBnbG9iYWwgYWxlcnQgbWVzc2FnZSwgb3IgZXZlbiBkbyBub3Qgc2hvdyBhbnl0aGluZyBpZiBub3QgbmVjZXNzYXJ5IChkbyBub3QgYWQgYW4gZXJyb3IgaGFuZGxlciBpbiBiZWxvdyBoYW5kbGVycyBvZiB0aGlzIHByb21pc2UpLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhamF4IGNhbGwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBzdWNjZXNzIG9yIGZhaWx1cmUuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogT0Utc3BlY2lmaWMgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLiR3aW5kb3cuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiR3aW5kb3cucHJldmVudEJsb2NrVUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdCBjb3JlIGFwaSBjb25maWcgZGF0YSBvbiBjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBoYXJkIGNvZGVkIHBhdGggZm9yIENvcmVyQXBpQXV0aEN0cmwgdG8gaW5qZWN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLiRodHRwLmdldCh0aGlzLmJ1aWxkVXJsRnJvbUNvbnRleHQoJ0NvcmVBcGlBdXRoL0dldENvcmVBcGlDb25maWcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdWNjZXNzKGZ1bmN0aW9uIChjb3JlQXBpQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hcGlDb25maWcgPSBjb3JlQXBpQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9KS5lcnJvcihmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byByZXRyaWV2ZSBBUEkgY29uZmlnLiBBYm9ydGluZyBodHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vI2VuZHJlZ2lvblxuICAgICAgICAgICAgICAgIC8vI3JlZ2lvbiBwdWJsaWMgbWV0aG9kc1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5ERUxFVEUsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5QVVQsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUudXBsb2FkID0gZnVuY3Rpb24gKHVybCwgZmlsZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZSAmJiAoIWNvbmZpZyB8fCAhY29uZmlnLmZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ0Nhbm5vdCBzdGFydCB1cGxvYWQgd2l0aCBudWxsIHtmaWxlfSBwYXJhbWV0ZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5maWxlID0gZmlsZSB8fCBjb25maWcuZmlsZTsgLy9UT0RPIE1HQSA6IGRvIG5vdCBleHBvc2UgZmlsZSBpbiBJSHR0cFdyYXBwZXJDb25maWcgP1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnVwbG9hZEluQmFzZTY0SnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogbWFrZSBzdXJlIHRoaXMgZGVsYXlzIG5leHQgY2FsbCBhbmQgdXBsb2FkIGlzIG5vdCBkb25lIGJlZm9yZSBiYXNlNjQgZW5jb2RpbmcgaXMgZmluaXNoZWQsIGV2ZW4gaWYgcHJvbWlzZSBpcyBhbHJlYWR5IHJlc29sdmVkID8/P1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVXBsb2FkLmJhc2U2NERhdGFVcmwoZmlsZSkudGhlbihmdW5jdGlvbiAoZmlsZUJhc2U2NFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQtY29kZWQga2V5IHRvIGZldGNoIGJhc2U2NCBlbmNvZGluZywgdG8gcGFyYW1ldHJpemUgd2l0aCBzZXJ2ZXItc2lkZSAhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUJhc2U2NFVybCA9IGZpbGVCYXNlNjRVcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3JtYWwgcG9zdCBpbiBjYXNlIG9mIGJhc2U2NC1lbmNvZGVkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYWpheChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUZvcm1EYXRhTmFtZSA9ICdmaWxlJzsgLy8gZmlsZSBmb3JtRGF0YSBuYW1lICgnQ29udGVudC1EaXNwb3NpdGlvbicpLCBzZXJ2ZXIgc2lkZSByZXF1ZXN0IGZvcm0gbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgKGluaXRDYWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG5vdCBzYWZlIGhhcmQgY2FzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBiZWhhdmlvciBkdXBsaWNhdGlvbiB3aXRoIHRoaXMuYWpheCwgbm90IERSWSwgdG8gaW1wcm92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5VcGxvYWQudXBsb2FkKF90aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihfdGhpcy5vblN1Y2Nlc3MsIF90aGlzLm9uRXJyb3IsIGNvbmZpZy51cGxvYWRQcm9ncmVzcykgLy9UT0RPIE1HQSA6IHVwbG9hZFByb2dyZXNzIGNhbGxiYWNrIG9rID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoX3RoaXMuZmluYWxseSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBkb3dubG9hZCBhIGZpbGUgaW4gdGhlIGZvcm0gb2YgYSBieXRlLXN0cmVhbSBmcm9tIGFuIGVuZHBvaW50IGFuZCB3cmFwIGl0IGludG8gYSBGaWxlQ29udGVudCBvYmplY3Qgd2l0aCBuYW1lLCB0eXBlICYgc2l6ZSBwcm9wZXJ0aWVzIHJlYWQgZnJvbSB0aGUgSFRUUCByZXNwb25zZSBoZWFkZXJzIG9mIHRoZSBzZXJ2ZXVyLlxuICAgICAgICAgICAgICAgICAqIEl0IGlzIHRoZSByZXNwb25zYWJpbGl0eSBvZiB0aGUgY29uc3VtZXIgdG8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHdyYXBwZWQgYnl0ZUFycmF5IChmb3IgZXhhbXBsZSBkb3dubG9hZCB0aGUgZmlsZSwgb3Igc2hvdyBpdCBpbnNpZGUgdGhlIHdlYlBhZ2UgZXRjKS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdXJsXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkTmFtZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHBlY3RlZFNpemVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRUeXBlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUuZ2V0RmlsZSA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmd1bGFySHR0cENvbmZpZyA9IF90aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2FsbHkgZXhwZWN0IHJhdyByZXNwb25zZSB0eXBlLCBvdGhlcndpc2UgYnl0ZSBzdHJlYW0gcmVzcG9uc2VzIGFyZSBjb3JydXB0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFySHR0cENvbmZpZy5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9FeHBlY3RlZCBBcnJheUJ1ZmZlciByZXNwb25zZSA9IGJ5dGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kaHR0cChhbmd1bGFySHR0cENvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoaHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iZW5lZml0IGZyb20gc3VjY2Vzc0NhbGxiYWNrIHZhbGlkYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSBfdGhpcy5vblN1Y2Nlc3MoaHR0cFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBwcm9taXNlIHJlamVjdGlvbiB2cy4gcmV0dXJuIG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvL3N0b3AgcHJvY2Vzc2luZyBpZiB1bmFibGUgdG8gcmV0cmlldmUgYnl0ZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVhZCBmaWxlIGluZm8gZnJvbSByZXNwb25zZS1oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVDb250ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfdGhpcy5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogTnVtYmVyKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWxlbmd0aCcpKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFycmF5QnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5vbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtZXRob2QgdG9vIHNwZWNpZmljIHRvIE9NIGFwcHMgY29udGV4dCwgbWF5IG5vdCB3b3JrIG91dHNpZGUgb2YgaXQsIHRvIGFkYXB0IGZvciBwdWJsaWMgdXNlID9cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUcmllcyB0byBwYXJzZSB0aGUgaW5wdXQgdXJsIDpcbiAgICAgICAgICAgICAgICAgKiBJZiBpdCBzZWVtcyB0byBiZSBhIGZ1bGwgVVJMLCB0aGVuIHJldHVybiBhcyBpcyAoY29uc2lkZXJzIGl0IGV4dGVybmFsIFVybClcbiAgICAgICAgICAgICAgICAgKiBPdGhlcndpc2UsIHRyaWVzIHRvIGZpbmQgdGhlIGJhc2UgVVJMIG9mIHRoZSBjdXJyZW50IEJsdWVTa3kgYXBwIHdpdGggb3Igd2l0aG91dCB0aGUgaW5jbHVkZWQgQ29udHJvbGxlciBhbmQgcmV0dXJucyB0aGUgZnVsbCBVcmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdXJsSW5wdXQgOiBUT0RPIE1HQTogZG9jdW1lbnQgZGlmZmVyZW50IGtpbmQgb2YgdXJscyB0aGF0IHRoaXMgbWV0aG9kIGNhbiB0YWtlIGFzIGlucHV0IChmdWxsLCBwYXJ0aWFsIGV0YylcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLmJ1aWxkVXJsRnJvbUNvbnRleHQgPSBmdW5jdGlvbiAodXJsSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMSAtIFVybCBzdGFydHMgd2l0aCBodHRwOi8vIG9yIGh0dHBzOi8vID0+IHJldHVybiBhcyBpcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybElucHV0LnNsaWNlKDAsICdodHRwOi8vJy5sZW5ndGgpID09PSAnaHR0cDovLycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybElucHV0LnNsaWNlKDAsICdodHRwczovLycubGVuZ3RoKSA9PT0gJ2h0dHBzOi8vJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybElucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIDIgLSBPdGhlcndpc2UsIHRyeSB0byBmaW5kIGNvcnJlY3QgY29udHJvbGxlclxuICAgICAgICAgICAgICAgICAgICAvLyBCb29sZWFuIHVzZWQgdG8gdHJ5IHRvIGRldGVybWluZSBjb3JyZWN0IGZ1bGwgdXJsIChhZGQgLyBvciBub3QgYmVmb3JlIHRoZSB1cmwgZnJhZ21lbnQgZGVwZW5kaW5nIG9uIGlmIGZvdW5kIG9yIG5vdClcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID0gdXJsSW5wdXQuc2xpY2UoMCwgJy8nLmxlbmd0aCkgPT09ICcvJztcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVnZXggdHJ5aW5nIHRvIGRldGVybWluZSBpZiB0aGUgaW5wdXQgZnJhZ21lbnQgY29udGFpbnMgYSAvIGJldHdlZW4gdHdvIGNoYXJhY3RlciBzdWl0ZXMgPT4gY29udHJvbGxlciBnaXZlbiBhcyBpbnB1dCwgb3RoZXJ3aXNlLCBhY3Rpb24gb24gc2FtZSBjb250cm9sbGVyIGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVySXNQcmVzZW50UmVnZXggPSAvXFx3K1xcL1xcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uSXNPblNhbWVDb250cm9sbGVyID0gIWNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleC50ZXN0KHVybElucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSB0aGlzLmdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyAodXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2ggPyB1cmxJbnB1dCA6ICgnLycgKyB1cmxJbnB1dCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIHByaXZhdGUgbWV0aG9kc1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFV0aWxpdHkgbWV0aG9kLlxuICAgICAgICAgICAgICAgICAqIE1haW4gY2FsbGVyIHRoYXQgYWxsIHdyYXBwZXIgY2FsbHMgKGdldCwgZGVsZXRlLCBwb3N0LCBwdXQpIG11c3QgdXNlIHRvIHNoYXJlIGNvbW1vbiBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5hamF4ID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1ha2Ugc3VyZSBpbml0UHJvbWlzZSByZXNvbHZlIGF1dG9tYXRpY2FsbHkgd2l0aG91dCBvdmVyaGVhZCBvbmNlIGZpcnN0IGNhbGwgc3VjZXNzZnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgKGluaXRDYWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmd1bGFySHR0cENvbmZpZyA9IF90aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKG1ldGhvZCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRodHRwKGFuZ3VsYXJIdHRwQ29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLm9uU3VjY2VzcywgX3RoaXMub25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShfdGhpcy5maW5hbGx5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHVzaW5nIG1ldGhvZCBmcm9tIExheW91dC5qcyA6IHRvIGRvY3VtZW50IHRvIG5vdCBoYW5kbGUgZHVwbGljYXRlIGNvZGUgISFcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiB1bnJvYnVzdCwgbmVlZHMgc29saWQgcmVmYWN0byB0byBtYWtlIGl0IG1vcmUgZ2VuZXJpYyB3aGVuIG9uIG9yaWdpbiBkb21haW4gIVxuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUuZ2V0VXJsUGF0aCA9IGZ1bmN0aW9uIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxPbUFwcHNSZWdleCA9IC8oXFwvXFx3K1xcL1xcKFNcXChcXHcrXFwpXFwpKVxcL1xcdyovO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNSZWdleCA9IC8oXFwvXFx3KylcXC9cXHcqLztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuJHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxPbUFwcHNNYXRjaGVzID0gYmFzZVVybE9tQXBwc1JlZ2V4LmV4ZWModXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcyA9IGJhc2VVcmxBc3BBcHBzUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gMiBtYXRjaGVzID0gcmVnZXggbWF0Y2hlcyArIHRoZSBjYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VVcmxPbUFwcHNNYXRjaGVzICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsT21BcHBzTWF0Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiYXNlVXJsQXNwQXBwc01hdGNoZXMgJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsQXNwQXBwc01hdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybEFzcEFwcHNNYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyICYmIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9NLXNwZWNpZmljIEFTUCBNVkMgY29kZSwgbm90IHVzZWQgQVRNLCB0byByZW1vdmVcbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLmdldEN1cnJlbnRTZXNzaW9uSUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBtYWdpYyByZWdleHAgdG8gZmV0Y2ggU2Vzc2lvbklEIGluIFVSTCwgdG8gc3RvcmUgZWxzZXdoZXJlICFcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvW1xcdy5dK1xcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIHNlc3Npb25SZWdleCA9IC9odHRwczpcXC9cXC9bXFx3Ll0rXFwvT3JkZXJFbnRyeVxcLyhcXChTXFwoXFx3K1xcKVxcKSlcXC8uKi87XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuJGxvY2F0aW9uLmFic1VybCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWdleHBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gcmVjb2duaXplZCBzZWFyY2hlZCBwYXR0ZXJuIGluIGN1cnJlbnQgdXJsIGxvY2F0aW9uIHRvIHJldHJpZXZlIHNlc3Npb25JRC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlc3Npb25JRCBpbiBzZWFyY2hlZCBwYXR0ZXJuIGluIGN1cnJlbnQgdXJsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1RvbyBtYW55IG1hdGNoZXMgZm91bmQgZm9yIHRoZSBzZXNzaW9uSUQgc2VhcmNoIGluIHRoZSBjdXJyZW50IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhwQXJyYXlbMV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUcmltIHRoZSBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciB0byByZXR1cm4gb25seSB0aGUgZmlsZW5hbWUuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUuZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uID0gZnVuY3Rpb24gKGNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyLnNwbGl0KCc7JylbMV0udHJpbSgpLnNwbGl0KCc9JylbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEh0dHBXcmFwcGVyU2VydmljZTtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBzZXJ2aWNlcy5IdHRwV3JhcHBlclNlcnZpY2UgPSBIdHRwV3JhcHBlclNlcnZpY2U7XG4gICAgICAgICAgICBhbmd1bGFyLm1vZHVsZSgnbmcuaHR0cFdyYXBwZXInLCBbJ3RvYXN0ZXInLCAnbmdBbmltYXRlJywgJ25nRmlsZVVwbG9hZCddKVxuICAgICAgICAgICAgICAgIC5zZXJ2aWNlKCdodHRwV3JhcHBlclNlcnZpY2UnLCBIdHRwV3JhcHBlclNlcnZpY2UpO1xuICAgICAgICB9KShzZXJ2aWNlcyA9IGNvcmUuc2VydmljZXMgfHwgKGNvcmUuc2VydmljZXMgPSB7fSkpO1xuICAgIH0pKGNvcmUgPSBibHVlc2t5LmNvcmUgfHwgKGJsdWVza3kuY29yZSA9IHt9KSk7XG59KShibHVlc2t5IHx8IChibHVlc2t5ID0ge30pKTtcbiJdfQ==
