var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var models;
        (function (models) {
            /**
             * TODO MGA : export an interface too ?
             */
            var ApiConfig = (function () {
                function ApiConfig(coreApiUrl, 
                    //TODO MGA : to inject as generic list of custom headers to pass to $http service ?
                    jwtToken, currentUserRole) {
                    this.coreApiUrl = coreApiUrl;
                    this.jwtToken = jwtToken;
                    this.currentUserRole = currentUserRole;
                }
                return ApiConfig;
            }());
            models.ApiConfig = ApiConfig;
        })(models = core.models || (core.models = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var models;
        (function (models) {
            var FileContent = (function () {
                function FileContent(name, size, type, content) {
                    this.name = name;
                    this.size = size;
                    this.type = type;
                    this.content = content;
                }
                return FileContent;
            }());
            models.FileContent = FileContent;
        })(models = core.models || (core.models = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

var bluesky;
(function (bluesky) {
    var core;
    (function (core) {
        var services;
        (function (services) {
            var HttpMethod;
            (function (HttpMethod) {
                HttpMethod[HttpMethod["GET"] = 0] = "GET";
                HttpMethod[HttpMethod["POST"] = 1] = "POST";
                HttpMethod[HttpMethod["PUT"] = 2] = "PUT";
                HttpMethod[HttpMethod["DELETE"] = 3] = "DELETE";
            })(HttpMethod || (HttpMethod = {}));
            ;
            /**
             * TODO MGA : this may not need to be a dedicated service, it can also be incorporated into the httpInterceptor. Decide best approach depending on planned use.
             */
            var HttpWrapperService = (function () {
                //#endregion
                //#region ctor
                /* @ngInject */
                HttpWrapperService.$inject = ["$http", "$window", "$log", "$q", "$location", "Upload", "toaster"];
                function HttpWrapperService($http, $window, $log, $q, $location, Upload, toaster) {
                    var _this = this;
                    this.$http = $http;
                    this.$window = $window;
                    this.$log = $log;
                    this.$q = $q;
                    this.$location = $location;
                    this.Upload = Upload;
                    this.toaster = toaster;
                    /**
                    * Prepares a {@link ng#$http#config config} object for $http call.
                    * The operations include setting default values when not provided, and setting http headers if needed for :
                    *  - Ajax calls
                    *  - Authorization token
                    *  - Current UserRole.
                    * @param options
                    * @returns {ng.$http.config} the configuration object ready to be injected into a $http call.
                    */
                    this.configureHttpCall = function (method, url, config) {
                        if (!url || method === null || method === undefined) {
                            _this.$log.error('URL & METHOD parameters are necessary for httpWrapper calls. Aborting.');
                            return null;
                        }
                        //Init config even if not provided
                        config = config || {};
                        //TODO MGA: hard cast is not safe, we may forget to set url & method parameters. TOFIX.
                        // automatically get all non-filtered parameters & keep them for this new object.
                        var configFull = config;
                        //TODO MGA: support mapping between upload & post here ?
                        configFull.method = HttpMethod[method];
                        if (config.apiEndpoint && (!_this.apiConfig ||
                            !_this.apiConfig.jwtToken ||
                            !_this.apiConfig.currentUserRole)) {
                            _this.$log.error("[InternalError] [" + configFull.method + " / " + url + "] - coreApi call intended without necessary capi credentials. Aborting.");
                            return null;
                        }
                        configFull.headers = config.headers || {};
                        if (!config.apiEndpoint) {
                            configFull.url = _this.buildUrlFromContext(url);
                        }
                        else {
                            //TODO MGA : core api endpoint 'api/' hardcoded, to put in configFull ! should not know that here.
                            configFull.url = _this.apiConfig.coreApiUrl + 'api/' + url;
                            if (_this.apiConfig.jwtToken && _this.apiConfig.currentUserRole) {
                                //TODO MGA: hard coded headers, not good, to inject
                                configFull.headers['OA-UserRole'] = _this.apiConfig.currentUserRole;
                                configFull.headers['Authorization'] = 'Bearer ' + _this.apiConfig.jwtToken;
                            }
                        }
                        if (!config.disableXmlHttpRequestHeader)
                            configFull.headers['X-Requested-With'] = 'XMLHttpRequest';
                        //TODO MGA: OE specific code, to remove
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = true;
                        return configFull;
                    };
                    /**
                     * Success handler.
                     * Captures the input parameters at the moment of its declaration & return the real handler to be called upon promise completion.
                     * Input parameters:
                     *  - callingConfig: configuration used to make the ajax call, in case the returned promise is null/empty and doesn't contain necessary data for debugging.
                     *  - getCompleteResponseObject: flag indication if we must return the full response object along with headers and status or only the inner data. By default & if not specified, only returns inner data.
                     */
                    this.onSuccess = function (httpPromise) {
                        if (!httpPromise) {
                            _this.$log.error("[HTTP no-response] Unexpected $http error, no response promise returned.");
                            _this.toaster.error('Unexpected behavior', 'Please contact your local support team.');
                            return null;
                        }
                        //TODO MGA: handle when API is fixed. See http://stackoverflow.com/questions/11746894/what-is-the-proper-rest-response-code-for-a-valid-request-but-an-empty-data
                        //if ((promiseCallback.data === null || promiseCallback.data === undefined) && promiseCallback.status !== 204) {
                        //    this.$log.error('Unexpected response from the server, expected response data but none found.');
                        //    this.toaster.warning('Unexpected response', 'Please contact your local support team.');
                        //    return this.$q.reject(promiseCallback); // Reject promise if not well-formed data
                        //}
                        //TODO MGA: same behavior also on a GET request ? if request is GET and response is 200 with no data, return error ? (pass in parameter request context to log this error).
                        //TODO MGA: get full url of request
                        _this.$log.debug("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                        // return only the data expected for caller
                        return httpPromise.data;
                    };
                    /**
                     * Error handler
                     * @param httpPromise
                     * @returns {}
                     */
                    this.onError = function (httpPromise) {
                        // We suppose in case of no response that the srv didn't send any response.
                        // TODO MGA: may also be a fault in internal $http / ajax client side lib, to distinguish.
                        if (!httpPromise || !httpPromise.data) {
                            httpPromise.data = 'Server not responding';
                            httpPromise.status = 503;
                        }
                        var contentType = httpPromise.headers('Content-Type');
                        if (contentType && (contentType.indexOf('application/json') > -1 || contentType.indexOf('text/plain') > -1)) {
                            var message = ""; //default message
                            //TODO MGA: handle error handling more generically based on input error message contract instead of expecting specific error strcture.
                            //if (response.data.ModelState) {
                            //    //TODO MGA : handle this when well formatted server-side
                            //} else
                            if (httpPromise.data.Message && angular.isString(httpPromise.data.Message)) {
                                message = httpPromise.data.Message;
                            }
                            else if (angular.isString(httpPromise.data)) {
                                message = httpPromise.data;
                            }
                            //TODO MGA: handle more response codes gracefully.
                            if (httpPromise.status === 404) {
                                _this.toaster.warning('Not Found', message);
                            }
                            else {
                                _this.toaster.error('Server response error', message + '\n Status: ' + httpPromise.status);
                            }
                        }
                        else {
                            _this.toaster.error('Internal server error', 'Status: ' + httpPromise.status);
                        }
                        //TODO MGA: get full url of request
                        _this.$log.error("[HTTP " + httpPromise.config.method + "] [" + httpPromise.config.url + "]", httpPromise);
                        // We don't recover from error, so we propagate it : below handlers have the choice of reading the error with an error handler or not. See $q promises behavior here : https://github.com/kriskowal/q
                        // This behavior is desired so that we show error inside specific server communication modals at specific places in the app, otherwise show a global alert message, or even do not show anything if not necessary (do not ad an error handler in below handlers of this promise).
                        return _this.$q.reject(httpPromise);
                    };
                    /**
                     * Function called at the end of an ajax call, regardless of it's success or failure.
                     * @param response
                     */
                    this.finally = function () {
                        //TODO MGA: OE-specific code
                        if (_this.$window.block_UI !== undefined)
                            // TODO MGA : type casting, is it okay or not ? better approach ?
                            _this.$window.preventBlockUI = false;
                    };
                    // init core api config data on ctor
                    //TODO MGA : hard coded path for CorerApiAuthCtrl to inject
                    this.initPromise = this.$http.get(this.buildUrlFromContext('CoreApiAuth/GetCoreApiConfig'))
                        .success(function (coreApiConfig) {
                        _this.apiConfig = coreApiConfig;
                    }).error(function (error) {
                        _this.$log.error('Unable to retrieve API config. Aborting httpWrapperService initialization.');
                        return $q.reject(error);
                    });
                }
                //#endregion
                //#region public methods
                HttpWrapperService.prototype.get = function (url, config) {
                    return this.ajax(HttpMethod.GET, url, config);
                };
                HttpWrapperService.prototype.delete = function (url, config) {
                    return this.ajax(HttpMethod.DELETE, url, config);
                };
                HttpWrapperService.prototype.post = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    ;
                    return this.ajax(HttpMethod.POST, url, config);
                };
                HttpWrapperService.prototype.put = function (url, data, config) {
                    config = config || {};
                    config.data = data || config.data;
                    return this.ajax(HttpMethod.PUT, url, config);
                };
                HttpWrapperService.prototype.upload = function (url, file, config) {
                    var _this = this;
                    if (!file && (!config || !config.file)) {
                        this.$log.error('Cannot start upload with null {file} parameter.');
                        return null;
                    }
                    config = config || {};
                    config.file = file || config.file; //TODO MGA : do not expose file in IHttpWrapperConfig ?
                    config.data = config.data || {};
                    if (config.uploadInBase64Json) {
                        //TODO MGA: make sure this delays next call and upload is not done before base64 encoding is finished, even if promise is already resolved ???
                        return this.Upload.base64DataUrl(file).then(function (fileBase64Url) {
                            //TODO MGA: hard-coded key to fetch base64 encoding, to parametrize with server-side !
                            config.data.fileBase64Url = fileBase64Url;
                            //normal post in case of base64-encoded data
                            return _this.ajax(HttpMethod.POST, url, config);
                        });
                    }
                    else {
                        config.data.fileFormDataName = 'file'; // file formData name ('Content-Disposition'), server side request form name
                        //TODO MGA : do not block if not call to internal API (initCall)
                        return this.initPromise.then(function () {
                            //TODO MGA : not safe hard cast
                            //TODO MGA : behavior duplication with this.ajax, not DRY, to improve
                            return _this.Upload.upload(_this.configureHttpCall(HttpMethod.POST, url, config))
                                .then(_this.onSuccess, _this.onError, config.uploadProgress) //TODO MGA : uploadProgress callback ok ?
                                .finally(_this.finally);
                        });
                    }
                };
                /**
                 * This method is used to download a file in the form of a byte-stream from an endpoint and wrap it into a FileContent object with name, type & size properties read from the HTTP response headers of the serveur.
                 * It is the responsability of the consumer to do something with the wrapped byteArray (for example download the file, or show it inside the webPage etc).
                 * @param url
                 * @param expectedName
                 * @param expectedSize
                 * @param expectedType
                 * @param config
                 */
                HttpWrapperService.prototype.getFile = function (url, config) {
                    var _this = this;
                    return this.initPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(HttpMethod.GET, url, config);
                        // specifically expect raw response type, otherwise byte stream responses are corrupted.
                        angularHttpConfig.responseType = 'arraybuffer';
                        //Expected ArrayBuffer response = byte array
                        return _this.$http(angularHttpConfig)
                            .then(function (httpResponse) {
                            //benefit from successCallback validation before continuing
                            var arrayBuffer = _this.onSuccess(httpResponse);
                            //TODO MGA: promise rejection vs. return null ?
                            if (!arrayBuffer)
                                return null; //stop processing if unable to retrieve byte array
                            //read file info from response-headers
                            var fileContent = {
                                name: _this.getFileNameFromHeaderContentDisposition(httpResponse.headers('content-disposition')) || null,
                                size: Number(httpResponse.headers('content-length')) || 0,
                                type: httpResponse.headers('content-type') || 'application/octet-stream',
                                content: arrayBuffer
                            };
                            return fileContent;
                        }, _this.onError)
                            .finally(_this.finally);
                    });
                };
                //TODO MGA : method too specific to OM apps context, may not work outside of it, to adapt for public use ?
                /**
                 * Tries to parse the input url :
                 * If it seems to be a full URL, then return as is (considers it external Url)
                 * Otherwise, tries to find the base URL of the current BlueSky app with or without the included Controller and returns the full Url
                 * @param urlInput : TODO MGA: document different kind of urls that this method can take as input (full, partial etc)
                 */
                HttpWrapperService.prototype.buildUrlFromContext = function (urlInput) {
                    // 1 - Url starts with http:// or https:// => return as is.
                    if (urlInput.slice(0, 'http://'.length) === 'http://' ||
                        urlInput.slice(0, 'https://'.length) === 'https://') {
                        return urlInput;
                    }
                    // 2 - Otherwise, try to find correct controller
                    // Boolean used to try to determine correct full url (add / or not before the url fragment depending on if found or not)
                    var urlFragmentStartsWithSlash = urlInput.slice(0, '/'.length) === '/';
                    // Regex trying to determine if the input fragment contains a / between two character suites => controller given as input, otherwise, action on same controller expected
                    var controllerIsPresentRegex = /\w+\/\w+/;
                    var actionIsOnSameController = !controllerIsPresentRegex.test(urlInput);
                    var baseUrl = this.getUrlPath(actionIsOnSameController);
                    return baseUrl + (urlFragmentStartsWithSlash ? urlInput : ('/' + urlInput));
                };
                //#endregion
                //#region private methods
                /**
                 * Utility method.
                 * Main caller that all wrapper calls (get, delete, post, put) must use to share common behavior.
                 * @param config
                 */
                HttpWrapperService.prototype.ajax = function (method, url, config) {
                    var _this = this;
                    //TODO MGA : make sure initPromise resolve automatically without overhead once first call sucessfull.
                    //TODO MGA : do not block if not call to internal API (initCall)
                    return this.initPromise.then(function () {
                        var angularHttpConfig = _this.configureHttpCall(method, url, config);
                        return _this.$http(angularHttpConfig)
                            .then(_this.onSuccess, _this.onError)
                            .finally(_this.finally);
                    });
                };
                // TODO MGA : using method from Layout.js : to document to not handle duplicate code !!
                //TODO MGA: unrobust, needs solid refacto to make it more generic when on origin domain !
                HttpWrapperService.prototype.getUrlPath = function (actionIsOnSameController) {
                    var baseUrlOmAppsRegex = /(\/\w+\/\(S\(\w+\)\))\/\w*/;
                    var baseUrlAspAppsRegex = /(\/\w+)\/\w*/;
                    var url = this.$window.location.pathname;
                    var baseUrlOmAppsMatches = baseUrlOmAppsRegex.exec(url);
                    var baseUrlAspAppsMatches = baseUrlAspAppsRegex.exec(url);
                    var baseUrlWithControllerName = null;
                    var baseUrl = null;
                    // 2 matches = regex matches + the capturing group
                    if (baseUrlOmAppsMatches && baseUrlOmAppsMatches.length && baseUrlOmAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlOmAppsMatches[0];
                        baseUrl = baseUrlOmAppsMatches[1];
                    }
                    else if (baseUrlAspAppsMatches && baseUrlAspAppsMatches.length && baseUrlAspAppsMatches.length === 2) {
                        baseUrlWithControllerName = baseUrlAspAppsMatches[0];
                        baseUrl = baseUrlAspAppsMatches[1];
                    }
                    if (actionIsOnSameController && baseUrlWithControllerName) {
                        return baseUrlWithControllerName;
                    }
                    else if (baseUrl) {
                        return baseUrl;
                    }
                    return '';
                };
                //TODO MGA: OM-specific ASP MVC code, not used ATM, to remove
                HttpWrapperService.prototype.getCurrentSessionID = function () {
                    //TODO MGA : magic regexp to fetch SessionID in URL, to store elsewhere !
                    var sessionRegex = /https:\/\/[\w.]+\/[\w.]+\/(\(S\(\w+\)\))\/.*/;
                    //var sessionRegex = /https:\/\/[\w.]+\/OrderEntry\/(\(S\(\w+\)\))\/.*/;
                    // TODO MGA : update regexp to the one below
                    //var baseUrlRegex = /(https:\/\/[\w.-]+\/[\w.-]+\/\(S\(\w+\)\)\/)\w+/;
                    var path = this.$location.absUrl();
                    var regexpArray = sessionRegex.exec(path);
                    if (!regexpArray) {
                        this.$log.error('Unable to recognized searched pattern in current url location to retrieve sessionID.');
                        return '';
                    }
                    if (regexpArray.length === 1) {
                        this.$log.error('Unable to find sessionID in searched pattern in current url.');
                        return '';
                    }
                    if (regexpArray.length > 2) {
                        this.$log.error('Too many matches found for the sessionID search in the current url.');
                        return '';
                    }
                    return regexpArray[1];
                };
                /**
                 * Trim the content-disposition header to return only the filename.
                 * @param contentDispositionHeader
                 */
                HttpWrapperService.prototype.getFileNameFromHeaderContentDisposition = function (contentDispositionHeader) {
                    if (!contentDispositionHeader)
                        return null;
                    var result = contentDispositionHeader.split(';')[1].trim().split('=')[1];
                    return result.replace(/"/g, '');
                };
                return HttpWrapperService;
            }());
            services.HttpWrapperService = HttpWrapperService;
            angular.module('ng.httpWrapper', ['toaster', 'ngAnimate', 'ngFileUpload'])
                .service('httpWrapperService', HttpWrapperService);
        })(services = core.services || (core.services = {}));
    })(core = bluesky.core || (bluesky.core = {}));
})(bluesky || (bluesky = {}));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwaS1jb25maWcubW9kZWwudHMiLCJmaWxlLWNvbnRlbnQubW9kZWwudHMiLCJodHRwLXdyYXBwZXIuc2VydmljZS50cyIsIm5nLWh0dHAtd3JhcHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFVO0FBQVYsQ0FBQSxVQUFVLFNBQU87SUFBQyxJQUFBO0lBQUEsQ0FBQSxVQUFBLE1BQUk7UUFBQyxJQUFBO1FBQUEsQ0FBQSxVQUFBLFFBQU87Ozs7WUFJMUIsSUFBQSxhQUFBLFlBQUE7Z0JBQ0ksU0FBQSxVQUNXOztvQkFFQSxVQUNBLGlCQUF1QjtvQkFIdkIsS0FBQSxhQUFBO29CQUVBLEtBQUEsV0FBQTtvQkFDQSxLQUFBLGtCQUFBOztnQkFFZixPQUFBOztZQVBhLE9BQUEsWUFBUztXQUpILFNBQUEsS0FBQSxXQUFBLEtBQUEsU0FBTTtPQUFYLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTzs7QUNBakIsSUFBVTtBQUFWLENBQUEsVUFBVSxTQUFPO0lBQUMsSUFBQTtJQUFBLENBQUEsVUFBQSxNQUFJO1FBQUMsSUFBQTtRQUFBLENBQUEsVUFBQSxRQUFPO1lBQzFCLElBQUEsZUFBQSxZQUFBO2dCQUNJLFNBQUEsWUFDVyxNQUNBLE1BQ0EsTUFDQSxTQUFvQjtvQkFIcEIsS0FBQSxPQUFBO29CQUNBLEtBQUEsT0FBQTtvQkFDQSxLQUFBLE9BQUE7b0JBQ0EsS0FBQSxVQUFBOztnQkFFZixPQUFBOztZQVBhLE9BQUEsY0FBVztXQURMLFNBQUEsS0FBQSxXQUFBLEtBQUEsU0FBTTtPQUFYLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTzs7QUNBakIsSUFBVTtBQUFWLENBQUEsVUFBVSxTQUFPO0lBQUMsSUFBQTtJQUFBLENBQUEsVUFBQSxNQUFJO1FBQUMsSUFBQTtRQUFBLENBQUEsVUFBQSxVQUFTO1lBZ0I1QixJQUFLO1lBQUwsQ0FBQSxVQUFLLFlBQVU7Z0JBQUcsV0FBQSxXQUFB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b0JBRTFCLElBQUksY0FBYyxhQUFhLEtBQUs7b0JBRXBDLElBQUksQ0FBQyxhQUFhO3dCQUNkLEtBQUssS0FBSyxNQUFNO3dCQUNoQixPQUFPOztvQkFFWCxJQUFJLFlBQVksV0FBVyxHQUFHO3dCQUMxQixLQUFLLEtBQUssTUFBTTt3QkFDaEIsT0FBTzs7b0JBRVgsSUFBSSxZQUFZLFNBQVMsR0FBRzt3QkFDeEIsS0FBSyxLQUFLLE1BQU07d0JBQ2hCLE9BQU87O29CQUdYLE9BQU8sWUFBWTs7Ozs7O2dCQU9mLG1CQUFBLFVBQUEsMENBQVIsVUFBZ0QsMEJBQWdDO29CQUM1RSxJQUFJLENBQUM7d0JBQTBCLE9BQU87b0JBRXRDLElBQUksU0FBUyx5QkFBeUIsTUFBTSxLQUFLLEdBQUcsT0FBTyxNQUFNLEtBQUs7b0JBRXRFLE9BQU8sT0FBTyxRQUFRLE1BQU07O2dCQUlwQyxPQUFBOztZQTFaYSxTQUFBLHFCQUFrQjtZQTRaL0IsUUFBUSxPQUFPLGtCQUFrQixDQUFDLFdBQVcsYUFBYTtpQkFLckQsUUFBUSxzQkFBc0I7V0FqZGhCLFdBQUEsS0FBQSxhQUFBLEtBQUEsV0FBUTtPQUFiLE9BQUEsUUFBQSxTQUFBLFFBQUEsT0FBSTtHQUFaLFlBQUEsVUFBTztBQ2laakIiLCJmaWxlIjoibmctaHR0cC13cmFwcGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibmFtZXNwYWNlIGJsdWVza3kuY29yZS5tb2RlbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPIE1HQSA6IGV4cG9ydCBhbiBpbnRlcmZhY2UgdG9vID9cclxuICAgICAqL1xyXG4gICAgZXhwb3J0IGNsYXNzIEFwaUNvbmZpZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgICAgIHB1YmxpYyBjb3JlQXBpVXJsOiBzdHJpbmcsXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiB0byBpbmplY3QgYXMgZ2VuZXJpYyBsaXN0IG9mIGN1c3RvbSBoZWFkZXJzIHRvIHBhc3MgdG8gJGh0dHAgc2VydmljZSA/XHJcbiAgICAgICAgICAgIHB1YmxpYyBqd3RUb2tlbjogc3RyaW5nLFxyXG4gICAgICAgICAgICBwdWJsaWMgY3VycmVudFVzZXJSb2xlOiBzdHJpbmdcclxuICAgICAgICApIHsgfVxyXG4gICAgfVxyXG59IiwibmFtZXNwYWNlIGJsdWVza3kuY29yZS5tb2RlbHMge1xyXG4gICAgZXhwb3J0IGNsYXNzIEZpbGVDb250ZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICAgICAgcHVibGljIG5hbWU6IHN0cmluZyxcclxuICAgICAgICAgICAgcHVibGljIHNpemU6IG51bWJlcixcclxuICAgICAgICAgICAgcHVibGljIHR5cGU6IHN0cmluZyxcclxuICAgICAgICAgICAgcHVibGljIGNvbnRlbnQ6IEFycmF5QnVmZmVyXHJcbiAgICAgICAgKSB7IH1cclxuICAgIH1cclxufSIsIm5hbWVzcGFjZSBibHVlc2t5LmNvcmUuc2VydmljZXMge1xyXG5cclxuICAgIGltcG9ydCBBcGlDb25maWcgPSBibHVlc2t5LmNvcmUubW9kZWxzLkFwaUNvbmZpZztcclxuICAgIGltcG9ydCBGaWxlQ29udGVudCA9IGJsdWVza3kuY29yZS5tb2RlbHMuRmlsZUNvbnRlbnQ7XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBJSHR0cFdyYXBwZXJDb25maWcgZXh0ZW5kcyBuZy5JUmVxdWVzdFNob3J0Y3V0Q29uZmlnIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtYWluIEFQSSBlbmRwb2ludCB0byB1c2UgYXMgZGVmYXVsdCBvbmUgaWYgdXJsIGlzIG5vdCBmdWxsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFwaUVuZHBvaW50PzogYm9vbGVhbjtcclxuICAgICAgICBmaWxlPzogRmlsZSxcclxuICAgICAgICB1cGxvYWRJbkJhc2U2NEpzb24/OiBib29sZWFuO1xyXG4gICAgICAgIHVwbG9hZFByb2dyZXNzPzogKCkgPT4gYW55O1xyXG4gICAgICAgIGRpc2FibGVYbWxIdHRwUmVxdWVzdEhlYWRlcj86IGJvb2xlYW47XHJcbiAgICB9XHJcblxyXG4gICAgZW51bSBIdHRwTWV0aG9kIHsgR0VULCBQT1NULCBQVVQsIERFTEVURSB9O1xyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgSUh0dHBXcmFwcGVyU2VydmljZSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbCBzcnYtc2lkZSBjb25maWd1cmF0aW9uIG9mIG1haW4gQVBJIHByb3ZpZGVkIGJ5IHRoZSBkb21haW4gZnJvbSB3aGljaCB0aGlzIHNjcmlwdCB3YXMgbG9hZGVkLCBAIHRoZSB1cmwgJ0NvcmVBcGlBdXRoL0dldENvcmVBcGlDb25maWcnLlxyXG4gICAgICAgICAqIFRPRE8gTUdBIGZpeCBoYXJkIGNvZGVkIHBhdGguXHJcbiAgICAgICAgICogVGhpcyBjb25maWd1cmF0aW9uIGRhdGEgaXMgbG9hZGVkIHVwb24gaW5pdGlhbGl6YXRpb24gb2YgdGhpcyBzZXJ2aWNlICh0byBiZSB1c2VkIGFzIGEgc2luZ2xldG9uIGluIHRoZSBhcHApLiBBbGwgb3RoZXIgd2ViIGNhbGxzIGFyZSBibG9ja2VkIGFzIGxvbmcgYXMgdGhpcyBvbmUgaXMgbm90IGZpbmlzaGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFwaUNvbmZpZzogQXBpQ29uZmlnO1xyXG5cclxuICAgICAgICAvL1RPRE8gTUdBOiBmb3IgZm9sbG93aW5nIG1ldGhvZHMsIHJldHVybiBJUHJvbWlzZSBhbmQgYXNzdW1lIGFic3RyYWN0aW9uIG9yIGxldCBiZWxvdyBzZXJ2aWNlcyBoYW5kbGUgSUh0dHBQcm9taXNlcyA/XHJcblxyXG4gICAgICAgIGdldDxUPih1cmw6IHN0cmluZywgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHBvc3Q8VD4odXJsOiBzdHJpbmcsIGRhdGE6IGFueSwgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD47XHJcblxyXG4gICAgICAgIHB1dDxUPih1cmw6IHN0cmluZywgZGF0YTogYW55LCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxUPjtcclxuXHJcbiAgICAgICAgLy9UT0RPIE1HQSBpbXByb3ZlIHR5cGluZyB3aXRoIGFuZ3VsYXItdXBsb2FkIHRzZCBldGNcclxuICAgICAgICB1cGxvYWQ8VD4odXJsOiBzdHJpbmcsIGZpbGU6IEZpbGUsIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+O1xyXG5cclxuICAgICAgICBnZXRGaWxlKHVybDogc3RyaW5nLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxGaWxlQ29udGVudD47XHJcblxyXG4gICAgICAgIGJ1aWxkVXJsRnJvbUNvbnRleHQodXJsSW5wdXQ6IHN0cmluZyk6IHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRPRE8gTUdBIDogdGhpcyBtYXkgbm90IG5lZWQgdG8gYmUgYSBkZWRpY2F0ZWQgc2VydmljZSwgaXQgY2FuIGFsc28gYmUgaW5jb3Jwb3JhdGVkIGludG8gdGhlIGh0dHBJbnRlcmNlcHRvci4gRGVjaWRlIGJlc3QgYXBwcm9hY2ggZGVwZW5kaW5nIG9uIHBsYW5uZWQgdXNlLlxyXG4gICAgICovXHJcbiAgICBleHBvcnQgY2xhc3MgSHR0cFdyYXBwZXJTZXJ2aWNlIGltcGxlbWVudHMgSUh0dHBXcmFwcGVyU2VydmljZSB7XHJcblxyXG4gICAgICAgIC8vI3JlZ2lvbiBwcm9wZXJ0aWVzXHJcblxyXG4gICAgICAgIHByaXZhdGUgaW5pdFByb21pc2U6IG5nLklQcm9taXNlPGFueT47XHJcbiAgICAgICAgcHVibGljIGFwaUNvbmZpZzogQXBpQ29uZmlnO1xyXG5cclxuICAgICAgICAvLyNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgLy8jcmVnaW9uIGN0b3JcclxuXHJcbiAgICAgICAgLyogQG5nSW5qZWN0ICovXHJcbiAgICAgICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgICAgIHByaXZhdGUgJGh0dHA6IG5nLklIdHRwU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkd2luZG93OiBuZy5JV2luZG93U2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkbG9nOiBuZy5JTG9nU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSAkcTogbmcuSVFTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlICRsb2NhdGlvbjogbmcuSUxvY2F0aW9uU2VydmljZSxcclxuICAgICAgICAgICAgcHJpdmF0ZSBVcGxvYWQ6IG5nLmFuZ3VsYXJGaWxlVXBsb2FkLklVcGxvYWRTZXJ2aWNlLFxyXG4gICAgICAgICAgICBwcml2YXRlIHRvYXN0ZXI6IG5ndG9hc3Rlci5JVG9hc3RlclNlcnZpY2VcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gaW5pdCBjb3JlIGFwaSBjb25maWcgZGF0YSBvbiBjdG9yXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBoYXJkIGNvZGVkIHBhdGggZm9yIENvcmVyQXBpQXV0aEN0cmwgdG8gaW5qZWN0XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLiRodHRwLmdldDxBcGlDb25maWc+KHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dCgnQ29yZUFwaUF1dGgvR2V0Q29yZUFwaUNvbmZpZycpKVxyXG4gICAgICAgICAgICAgICAgLnN1Y2Nlc3MoKGNvcmVBcGlDb25maWcpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwaUNvbmZpZyA9IGNvcmVBcGlDb25maWc7XHJcbiAgICAgICAgICAgICAgICB9KS5lcnJvcigoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byByZXRyaWV2ZSBBUEkgY29uZmlnLiBBYm9ydGluZyBodHRwV3JhcHBlclNlcnZpY2UgaW5pdGlhbGl6YXRpb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHVibGljIG1ldGhvZHNcclxuXHJcbiAgICAgICAgZ2V0PFQ+KHVybDogc3RyaW5nLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxUPiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlbGV0ZTxUPih1cmw6IHN0cmluZywgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuREVMRVRFLCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwb3N0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hamF4PFQ+KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHV0PFQ+KHVybDogc3RyaW5nLCBkYXRhOiBhbnksIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGRhdGEgfHwgY29uZmlnLmRhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXg8VD4oSHR0cE1ldGhvZC5QVVQsIHVybCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwbG9hZDxUPih1cmw6IHN0cmluZywgZmlsZTogRmlsZSwgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVByb21pc2U8VD4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKCFmaWxlICYmICghY29uZmlnIHx8ICFjb25maWcuZmlsZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignQ2Fubm90IHN0YXJ0IHVwbG9hZCB3aXRoIG51bGwge2ZpbGV9IHBhcmFtZXRlci4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XHJcbiAgICAgICAgICAgIGNvbmZpZy5maWxlID0gZmlsZSB8fCBjb25maWcuZmlsZTsgLy9UT0RPIE1HQSA6IGRvIG5vdCBleHBvc2UgZmlsZSBpbiBJSHR0cFdyYXBwZXJDb25maWcgP1xyXG4gICAgICAgICAgICBjb25maWcuZGF0YSA9IGNvbmZpZy5kYXRhIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbmZpZy51cGxvYWRJbkJhc2U2NEpzb24pIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IG1ha2Ugc3VyZSB0aGlzIGRlbGF5cyBuZXh0IGNhbGwgYW5kIHVwbG9hZCBpcyBub3QgZG9uZSBiZWZvcmUgYmFzZTY0IGVuY29kaW5nIGlzIGZpbmlzaGVkLCBldmVuIGlmIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCA/Pz9cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVwbG9hZC5iYXNlNjREYXRhVXJsKGZpbGUpLnRoZW4oKGZpbGVCYXNlNjRVcmwpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkLWNvZGVkIGtleSB0byBmZXRjaCBiYXNlNjQgZW5jb2RpbmcsIHRvIHBhcmFtZXRyaXplIHdpdGggc2VydmVyLXNpZGUgIVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhLmZpbGVCYXNlNjRVcmwgPSBmaWxlQmFzZTY0VXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbm9ybWFsIHBvc3QgaW4gY2FzZSBvZiBiYXNlNjQtZW5jb2RlZCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheDxUPihIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLmRhdGEuZmlsZUZvcm1EYXRhTmFtZSA9ICdmaWxlJzsgLy8gZmlsZSBmb3JtRGF0YSBuYW1lICgnQ29udGVudC1EaXNwb3NpdGlvbicpLCBzZXJ2ZXIgc2lkZSByZXF1ZXN0IGZvcm0gbmFtZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBkbyBub3QgYmxvY2sgaWYgbm90IGNhbGwgdG8gaW50ZXJuYWwgQVBJIChpbml0Q2FsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0EgOiBub3Qgc2FmZSBoYXJkIGNhc3RcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogYmVoYXZpb3IgZHVwbGljYXRpb24gd2l0aCB0aGlzLmFqYXgsIG5vdCBEUlksIHRvIGltcHJvdmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VcGxvYWQudXBsb2FkPFQ+KDxuZy5hbmd1bGFyRmlsZVVwbG9hZC5JRmlsZVVwbG9hZENvbmZpZ0ZpbGU+dGhpcy5jb25maWd1cmVIdHRwQ2FsbChIdHRwTWV0aG9kLlBPU1QsIHVybCwgY29uZmlnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW48VD4odGhpcy5vblN1Y2Nlc3MsIHRoaXMub25FcnJvciwgY29uZmlnLnVwbG9hZFByb2dyZXNzKSAvL1RPRE8gTUdBIDogdXBsb2FkUHJvZ3Jlc3MgY2FsbGJhY2sgb2sgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseSh0aGlzLmZpbmFsbHkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZG93bmxvYWQgYSBmaWxlIGluIHRoZSBmb3JtIG9mIGEgYnl0ZS1zdHJlYW0gZnJvbSBhbiBlbmRwb2ludCBhbmQgd3JhcCBpdCBpbnRvIGEgRmlsZUNvbnRlbnQgb2JqZWN0IHdpdGggbmFtZSwgdHlwZSAmIHNpemUgcHJvcGVydGllcyByZWFkIGZyb20gdGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyBvZiB0aGUgc2VydmV1ci5cclxuICAgICAgICAgKiBJdCBpcyB0aGUgcmVzcG9uc2FiaWxpdHkgb2YgdGhlIGNvbnN1bWVyIHRvIGRvIHNvbWV0aGluZyB3aXRoIHRoZSB3cmFwcGVkIGJ5dGVBcnJheSAoZm9yIGV4YW1wbGUgZG93bmxvYWQgdGhlIGZpbGUsIG9yIHNob3cgaXQgaW5zaWRlIHRoZSB3ZWJQYWdlIGV0YykuXHJcbiAgICAgICAgICogQHBhcmFtIHVybFxyXG4gICAgICAgICAqIEBwYXJhbSBleHBlY3RlZE5hbWVcclxuICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWRTaXplXHJcbiAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkVHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRGaWxlKHVybDogc3RyaW5nLCBjb25maWc/OiBJSHR0cFdyYXBwZXJDb25maWcpOiBuZy5JUHJvbWlzZTxGaWxlQ29udGVudD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZS50aGVuKCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYW5ndWxhckh0dHBDb25maWcgPSB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsKEh0dHBNZXRob2QuR0VULCB1cmwsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWNhbGx5IGV4cGVjdCByYXcgcmVzcG9uc2UgdHlwZSwgb3RoZXJ3aXNlIGJ5dGUgc3RyZWFtIHJlc3BvbnNlcyBhcmUgY29ycnVwdGVkLlxyXG4gICAgICAgICAgICAgICAgYW5ndWxhckh0dHBDb25maWcucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuXHJcbiAgICAgICAgICAgICAgICAvL0V4cGVjdGVkIEFycmF5QnVmZmVyIHJlc3BvbnNlID0gYnl0ZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGh0dHA8QXJyYXlCdWZmZXI+KGFuZ3VsYXJIdHRwQ29uZmlnKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuPEZpbGVDb250ZW50PigoaHR0cFJlc3BvbnNlKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2JlbmVmaXQgZnJvbSBzdWNjZXNzQ2FsbGJhY2sgdmFsaWRhdGlvbiBiZWZvcmUgY29udGludWluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIgPSB0aGlzLm9uU3VjY2VzczxBcnJheUJ1ZmZlcj4oaHR0cFJlc3BvbnNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHByb21pc2UgcmVqZWN0aW9uIHZzLiByZXR1cm4gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlCdWZmZXIpIHJldHVybiBudWxsOyAvL3N0b3AgcHJvY2Vzc2luZyBpZiB1bmFibGUgdG8gcmV0cmlldmUgYnl0ZSBhcnJheVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGZpbGUgaW5mbyBmcm9tIHJlc3BvbnNlLWhlYWRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVDb250ZW50OiBGaWxlQ29udGVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0RmlsZU5hbWVGcm9tSGVhZGVyQ29udGVudERpc3Bvc2l0aW9uKGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LWRpc3Bvc2l0aW9uJykpIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBOdW1iZXIoaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtbGVuZ3RoJykpIHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm9uRXJyb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkodGhpcy5maW5hbGx5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RPRE8gTUdBIDogbWV0aG9kIHRvbyBzcGVjaWZpYyB0byBPTSBhcHBzIGNvbnRleHQsIG1heSBub3Qgd29yayBvdXRzaWRlIG9mIGl0LCB0byBhZGFwdCBmb3IgcHVibGljIHVzZSA/XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZXMgdG8gcGFyc2UgdGhlIGlucHV0IHVybCA6XHJcbiAgICAgICAgICogSWYgaXQgc2VlbXMgdG8gYmUgYSBmdWxsIFVSTCwgdGhlbiByZXR1cm4gYXMgaXMgKGNvbnNpZGVycyBpdCBleHRlcm5hbCBVcmwpIFxyXG4gICAgICAgICAqIE90aGVyd2lzZSwgdHJpZXMgdG8gZmluZCB0aGUgYmFzZSBVUkwgb2YgdGhlIGN1cnJlbnQgQmx1ZVNreSBhcHAgd2l0aCBvciB3aXRob3V0IHRoZSBpbmNsdWRlZCBDb250cm9sbGVyIGFuZCByZXR1cm5zIHRoZSBmdWxsIFVybCBcclxuICAgICAgICAgKiBAcGFyYW0gdXJsSW5wdXQgOiBUT0RPIE1HQTogZG9jdW1lbnQgZGlmZmVyZW50IGtpbmQgb2YgdXJscyB0aGF0IHRoaXMgbWV0aG9kIGNhbiB0YWtlIGFzIGlucHV0IChmdWxsLCBwYXJ0aWFsIGV0YylcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdWJsaWMgYnVpbGRVcmxGcm9tQ29udGV4dCh1cmxJbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDEgLSBVcmwgc3RhcnRzIHdpdGggaHR0cDovLyBvciBodHRwczovLyA9PiByZXR1cm4gYXMgaXMuXHJcbiAgICAgICAgICAgIGlmICh1cmxJbnB1dC5zbGljZSgwLCAnaHR0cDovLycubGVuZ3RoKSA9PT0gJ2h0dHA6Ly8nIHx8XHJcbiAgICAgICAgICAgICAgICB1cmxJbnB1dC5zbGljZSgwLCAnaHR0cHM6Ly8nLmxlbmd0aCkgPT09ICdodHRwczovLycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmxJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gMiAtIE90aGVyd2lzZSwgdHJ5IHRvIGZpbmQgY29ycmVjdCBjb250cm9sbGVyXHJcblxyXG4gICAgICAgICAgICAvLyBCb29sZWFuIHVzZWQgdG8gdHJ5IHRvIGRldGVybWluZSBjb3JyZWN0IGZ1bGwgdXJsIChhZGQgLyBvciBub3QgYmVmb3JlIHRoZSB1cmwgZnJhZ21lbnQgZGVwZW5kaW5nIG9uIGlmIGZvdW5kIG9yIG5vdClcclxuICAgICAgICAgICAgdmFyIHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID0gdXJsSW5wdXQuc2xpY2UoMCwgJy8nLmxlbmd0aCkgPT09ICcvJztcclxuXHJcbiAgICAgICAgICAgIC8vIFJlZ2V4IHRyeWluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGZyYWdtZW50IGNvbnRhaW5zIGEgLyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXIgc3VpdGVzID0+IGNvbnRyb2xsZXIgZ2l2ZW4gYXMgaW5wdXQsIG90aGVyd2lzZSwgYWN0aW9uIG9uIHNhbWUgY29udHJvbGxlciBleHBlY3RlZFxyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlcklzUHJlc2VudFJlZ2V4ID0gL1xcdytcXC9cXHcrLztcclxuXHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSB0aGlzLmdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlVXJsICsgKHVybEZyYWdtZW50U3RhcnRzV2l0aFNsYXNoID8gdXJsSW5wdXQgOiAoJy8nICsgdXJsSW5wdXQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBtZXRob2RzXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFV0aWxpdHkgbWV0aG9kLlxyXG4gICAgICAgICAqIE1haW4gY2FsbGVyIHRoYXQgYWxsIHdyYXBwZXIgY2FsbHMgKGdldCwgZGVsZXRlLCBwb3N0LCBwdXQpIG11c3QgdXNlIHRvIHNoYXJlIGNvbW1vbiBiZWhhdmlvci5cclxuICAgICAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBhamF4PFQ+KG1ldGhvZDogSHR0cE1ldGhvZCwgdXJsOiBzdHJpbmcsIGNvbmZpZz86IElIdHRwV3JhcHBlckNvbmZpZyk6IG5nLklQcm9taXNlPFQ+IHtcclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1ha2Ugc3VyZSBpbml0UHJvbWlzZSByZXNvbHZlIGF1dG9tYXRpY2FsbHkgd2l0aG91dCBvdmVyaGVhZCBvbmNlIGZpcnN0IGNhbGwgc3VjZXNzZnVsbC5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGRvIG5vdCBibG9jayBpZiBub3QgY2FsbCB0byBpbnRlcm5hbCBBUEkgKGluaXRDYWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmd1bGFySHR0cENvbmZpZyA9IHRoaXMuY29uZmlndXJlSHR0cENhbGwobWV0aG9kLCB1cmwsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kaHR0cDxUPihhbmd1bGFySHR0cENvbmZpZylcclxuICAgICAgICAgICAgICAgICAgICAudGhlbjxUPih0aGlzLm9uU3VjY2VzcywgdGhpcy5vbkVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KHRoaXMuZmluYWxseSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBQcmVwYXJlcyBhIHtAbGluayBuZyMkaHR0cCNjb25maWcgY29uZmlnfSBvYmplY3QgZm9yICRodHRwIGNhbGwuXHJcbiAgICAgICAgKiBUaGUgb3BlcmF0aW9ucyBpbmNsdWRlIHNldHRpbmcgZGVmYXVsdCB2YWx1ZXMgd2hlbiBub3QgcHJvdmlkZWQsIGFuZCBzZXR0aW5nIGh0dHAgaGVhZGVycyBpZiBuZWVkZWQgZm9yIDpcclxuICAgICAgICAqICAtIEFqYXggY2FsbHNcclxuICAgICAgICAqICAtIEF1dGhvcml6YXRpb24gdG9rZW5cclxuICAgICAgICAqICAtIEN1cnJlbnQgVXNlclJvbGUuICAgXHJcbiAgICAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICAgICogQHJldHVybnMge25nLiRodHRwLmNvbmZpZ30gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHJlYWR5IHRvIGJlIGluamVjdGVkIGludG8gYSAkaHR0cCBjYWxsLiBcclxuICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgY29uZmlndXJlSHR0cENhbGwgPSAobWV0aG9kOiBIdHRwTWV0aG9kLCB1cmw6IHN0cmluZywgY29uZmlnPzogSUh0dHBXcmFwcGVyQ29uZmlnKTogbmcuSVJlcXVlc3RDb25maWcgPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKCF1cmwgfHwgbWV0aG9kID09PSBudWxsIHx8IG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VSTCAmIE1FVEhPRCBwYXJhbWV0ZXJzIGFyZSBuZWNlc3NhcnkgZm9yIGh0dHBXcmFwcGVyIGNhbGxzLiBBYm9ydGluZy4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL0luaXQgY29uZmlnIGV2ZW4gaWYgbm90IHByb3ZpZGVkXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY2FzdCBpcyBub3Qgc2FmZSwgd2UgbWF5IGZvcmdldCB0byBzZXQgdXJsICYgbWV0aG9kIHBhcmFtZXRlcnMuIFRPRklYLlxyXG4gICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGdldCBhbGwgbm9uLWZpbHRlcmVkIHBhcmFtZXRlcnMgJiBrZWVwIHRoZW0gZm9yIHRoaXMgbmV3IG9iamVjdC5cclxuICAgICAgICAgICAgdmFyIGNvbmZpZ0Z1bGwgPSA8bmcuSVJlcXVlc3RDb25maWc+Y29uZmlnO1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogc3VwcG9ydCBtYXBwaW5nIGJldHdlZW4gdXBsb2FkICYgcG9zdCBoZXJlID9cclxuICAgICAgICAgICAgY29uZmlnRnVsbC5tZXRob2QgPSBIdHRwTWV0aG9kW21ldGhvZF07XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLmFwaUVuZHBvaW50ICYmICghdGhpcy5hcGlDb25maWcgfHxcclxuICAgICAgICAgICAgICAgICF0aGlzLmFwaUNvbmZpZy5qd3RUb2tlbiB8fFxyXG4gICAgICAgICAgICAgICAgIXRoaXMuYXBpQ29uZmlnLmN1cnJlbnRVc2VyUm9sZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0ludGVybmFsRXJyb3JdIFske2NvbmZpZ0Z1bGwubWV0aG9kfSAvICR7dXJsfV0gLSBjb3JlQXBpIGNhbGwgaW50ZW5kZWQgd2l0aG91dCBuZWNlc3NhcnkgY2FwaSBjcmVkZW50aWFscy4gQWJvcnRpbmcuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5hcGlFbmRwb2ludCkgeyAvLyBpZiBub3Qgc2V0LCBldmFsdWF0ZXMgdG8gZmFsc2VcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwudXJsID0gdGhpcy5idWlsZFVybEZyb21Db250ZXh0KHVybCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogY29yZSBhcGkgZW5kcG9pbnQgJ2FwaS8nIGhhcmRjb2RlZCwgdG8gcHV0IGluIGNvbmZpZ0Z1bGwgISBzaG91bGQgbm90IGtub3cgdGhhdCBoZXJlLlxyXG4gICAgICAgICAgICAgICAgY29uZmlnRnVsbC51cmwgPSB0aGlzLmFwaUNvbmZpZy5jb3JlQXBpVXJsICsgJ2FwaS8nICsgdXJsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwaUNvbmZpZy5qd3RUb2tlbiAmJiB0aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlcnMsIG5vdCBnb29kLCB0byBpbmplY3RcclxuICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLmhlYWRlcnNbJ09BLVVzZXJSb2xlJ10gPSB0aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyB0aGlzLmFwaUNvbmZpZy5qd3RUb2tlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKSAvLyBpZiBub3Qgc2V0LCBldmFsdWF0ZXMgdG8gZmFsc2VcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FIHNwZWNpZmljIGNvZGUsIHRvIHJlbW92ZVxyXG4gICAgICAgICAgICBpZiAoKDxhbnk+dGhpcy4kd2luZG93KS5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB0eXBlIGNhc3RpbmcsIGlzIGl0IG9rYXkgb3Igbm90ID8gYmV0dGVyIGFwcHJvYWNoID9cclxuICAgICAgICAgICAgICAgICg8YW55PnRoaXMuJHdpbmRvdykucHJldmVudEJsb2NrVUkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ0Z1bGw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3VjY2VzcyBoYW5kbGVyLlxyXG4gICAgICAgICAqIENhcHR1cmVzIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIGF0IHRoZSBtb21lbnQgb2YgaXRzIGRlY2xhcmF0aW9uICYgcmV0dXJuIHRoZSByZWFsIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHVwb24gcHJvbWlzZSBjb21wbGV0aW9uLlxyXG4gICAgICAgICAqIElucHV0IHBhcmFtZXRlcnM6XHJcbiAgICAgICAgICogIC0gY2FsbGluZ0NvbmZpZzogY29uZmlndXJhdGlvbiB1c2VkIHRvIG1ha2UgdGhlIGFqYXggY2FsbCwgaW4gY2FzZSB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBudWxsL2VtcHR5IGFuZCBkb2Vzbid0IGNvbnRhaW4gbmVjZXNzYXJ5IGRhdGEgZm9yIGRlYnVnZ2luZy5cclxuICAgICAgICAgKiAgLSBnZXRDb21wbGV0ZVJlc3BvbnNlT2JqZWN0OiBmbGFnIGluZGljYXRpb24gaWYgd2UgbXVzdCByZXR1cm4gdGhlIGZ1bGwgcmVzcG9uc2Ugb2JqZWN0IGFsb25nIHdpdGggaGVhZGVycyBhbmQgc3RhdHVzIG9yIG9ubHkgdGhlIGlubmVyIGRhdGEuIEJ5IGRlZmF1bHQgJiBpZiBub3Qgc3BlY2lmaWVkLCBvbmx5IHJldHVybnMgaW5uZXIgZGF0YS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBwcml2YXRlIG9uU3VjY2VzcyA9IDxUPihodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8VD4pOiBUID0+IHtcclxuXHJcbiAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0hUVFAgbm8tcmVzcG9uc2VdIFVuZXhwZWN0ZWQgJGh0dHAgZXJyb3IsIG5vIHJlc3BvbnNlIHByb21pc2UgcmV0dXJuZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgYmVoYXZpb3InLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtdWx0aS10eXBlIHJldHVybiBpbiBjYXNlIG9mIHJlamVjdGlvbiBvciBkbyBzb21ldGhpbmcgZWxzZSA/IHRoaXMgbWV0aG9kIGlzIGN1cnJlbnRseSB1c2VkIHN5bmNocm9ub3VzbHkgd2l0aG91dCBwcm9taXNlIHdhaXRpbmcuXHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiB0aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7IC8vIFJlamVjdCBwcm9taXNlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSB3aGVuIEFQSSBpcyBmaXhlZC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3NDY4OTQvd2hhdC1pcy10aGUtcHJvcGVyLXJlc3QtcmVzcG9uc2UtY29kZS1mb3ItYS12YWxpZC1yZXF1ZXN0LWJ1dC1hbi1lbXB0eS1kYXRhXHJcbiAgICAgICAgICAgIC8vaWYgKChwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gbnVsbCB8fCBwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gdW5kZWZpbmVkKSAmJiBwcm9taXNlQ2FsbGJhY2suc3RhdHVzICE9PSAyMDQpIHtcclxuICAgICAgICAgICAgLy8gICAgdGhpcy4kbG9nLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciwgZXhwZWN0ZWQgcmVzcG9uc2UgZGF0YSBidXQgbm9uZSBmb3VuZC4nKTtcclxuICAgICAgICAgICAgLy8gICAgdGhpcy50b2FzdGVyLndhcm5pbmcoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UnLCAnUGxlYXNlIGNvbnRhY3QgeW91ciBsb2NhbCBzdXBwb3J0IHRlYW0uJyk7XHJcbiAgICAgICAgICAgIC8vICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChwcm9taXNlQ2FsbGJhY2spOyAvLyBSZWplY3QgcHJvbWlzZSBpZiBub3Qgd2VsbC1mb3JtZWQgZGF0YVxyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgLy9UT0RPIE1HQTogc2FtZSBiZWhhdmlvciBhbHNvIG9uIGEgR0VUIHJlcXVlc3QgPyBpZiByZXF1ZXN0IGlzIEdFVCBhbmQgcmVzcG9uc2UgaXMgMjAwIHdpdGggbm8gZGF0YSwgcmV0dXJuIGVycm9yID8gKHBhc3MgaW4gcGFyYW1ldGVyIHJlcXVlc3QgY29udGV4dCB0byBsb2cgdGhpcyBlcnJvcikuXHJcblxyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBnZXQgZnVsbCB1cmwgb2YgcmVxdWVzdFxyXG4gICAgICAgICAgICB0aGlzLiRsb2cuZGVidWcoYFtIVFRQICR7aHR0cFByb21pc2UuY29uZmlnLm1ldGhvZH1dIFske2h0dHBQcm9taXNlLmNvbmZpZy51cmx9XWAsIGh0dHBQcm9taXNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHJldHVybiBvbmx5IHRoZSBkYXRhIGV4cGVjdGVkIGZvciBjYWxsZXJcclxuICAgICAgICAgICAgcmV0dXJuIGh0dHBQcm9taXNlLmRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFcnJvciBoYW5kbGVyXHJcbiAgICAgICAgICogQHBhcmFtIGh0dHBQcm9taXNlIFxyXG4gICAgICAgICAqIEByZXR1cm5zIHt9IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByaXZhdGUgb25FcnJvciA9IChodHRwUHJvbWlzZTogbmcuSUh0dHBQcm9taXNlQ2FsbGJhY2tBcmc8YW55Pik6IG5nLklQcm9taXNlPG5nLklIdHRwUHJvbWlzZUNhbGxiYWNrQXJnPGFueT4+ID0+IHsgLy8gZG8gc29tZXRoaW5nIG9uIGVycm9yXHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzdXBwb3NlIGluIGNhc2Ugb2Ygbm8gcmVzcG9uc2UgdGhhdCB0aGUgc3J2IGRpZG4ndCBzZW5kIGFueSByZXNwb25zZS5cclxuICAgICAgICAgICAgLy8gVE9ETyBNR0E6IG1heSBhbHNvIGJlIGEgZmF1bHQgaW4gaW50ZXJuYWwgJGh0dHAgLyBhamF4IGNsaWVudCBzaWRlIGxpYiwgdG8gZGlzdGluZ3Vpc2guXHJcbiAgICAgICAgICAgIGlmICghaHR0cFByb21pc2UgfHwgIWh0dHBQcm9taXNlLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEgPSAnU2VydmVyIG5vdCByZXNwb25kaW5nJztcclxuICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLnN0YXR1cyA9IDUwMztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaHR0cFByb21pc2UuaGVhZGVycygnQ29udGVudC1UeXBlJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlOiBzdHJpbmcgPSBcIlwiOyAvL2RlZmF1bHQgbWVzc2FnZVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBlcnJvciBoYW5kbGluZyBtb3JlIGdlbmVyaWNhbGx5IGJhc2VkIG9uIGlucHV0IGVycm9yIG1lc3NhZ2UgY29udHJhY3QgaW5zdGVhZCBvZiBleHBlY3Rpbmcgc3BlY2lmaWMgZXJyb3Igc3RyY3R1cmUuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiAocmVzcG9uc2UuZGF0YS5Nb2RlbFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAvL1RPRE8gTUdBIDogaGFuZGxlIHRoaXMgd2hlbiB3ZWxsIGZvcm1hdHRlZCBzZXJ2ZXItc2lkZVxyXG4gICAgICAgICAgICAgICAgLy99IGVsc2VcclxuICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UgJiYgYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGEuTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtb3JlIHJlc3BvbnNlIGNvZGVzIGdyYWNlZnVsbHkuXHJcbiAgICAgICAgICAgICAgICBpZiAoaHR0cFByb21pc2Uuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnTm90IEZvdW5kJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci5lcnJvcignU2VydmVyIHJlc3BvbnNlIGVycm9yJywgbWVzc2FnZSArICdcXG4gU3RhdHVzOiAnICsgaHR0cFByb21pc2Uuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG9hc3Rlci5lcnJvcignSW50ZXJuYWwgc2VydmVyIGVycm9yJywgJ1N0YXR1czogJyArIGh0dHBQcm9taXNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XHJcbiAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcihgW0hUVFAgJHtodHRwUHJvbWlzZS5jb25maWcubWV0aG9kfV0gWyR7aHR0cFByb21pc2UuY29uZmlnLnVybH1dYCwgaHR0cFByb21pc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVjb3ZlciBmcm9tIGVycm9yLCBzbyB3ZSBwcm9wYWdhdGUgaXQgOiBiZWxvdyBoYW5kbGVycyBoYXZlIHRoZSBjaG9pY2Ugb2YgcmVhZGluZyB0aGUgZXJyb3Igd2l0aCBhbiBlcnJvciBoYW5kbGVyIG9yIG5vdC4gU2VlICRxIHByb21pc2VzIGJlaGF2aW9yIGhlcmUgOiBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3FcclxuICAgICAgICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBkZXNpcmVkIHNvIHRoYXQgd2Ugc2hvdyBlcnJvciBpbnNpZGUgc3BlY2lmaWMgc2VydmVyIGNvbW11bmljYXRpb24gbW9kYWxzIGF0IHNwZWNpZmljIHBsYWNlcyBpbiB0aGUgYXBwLCBvdGhlcndpc2Ugc2hvdyBhIGdsb2JhbCBhbGVydCBtZXNzYWdlLCBvciBldmVuIGRvIG5vdCBzaG93IGFueXRoaW5nIGlmIG5vdCBuZWNlc3NhcnkgKGRvIG5vdCBhZCBhbiBlcnJvciBoYW5kbGVyIGluIGJlbG93IGhhbmRsZXJzIG9mIHRoaXMgcHJvbWlzZSkuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChodHRwUHJvbWlzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBhbiBhamF4IGNhbGwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBzdWNjZXNzIG9yIGZhaWx1cmUuXHJcbiAgICAgICAgICogQHBhcmFtIHJlc3BvbnNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBmaW5hbGx5ID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICAvL1RPRE8gTUdBOiBPRS1zcGVjaWZpYyBjb2RlXHJcbiAgICAgICAgICAgIGlmICgoPGFueT50aGlzLiR3aW5kb3cpLmJsb2NrX1VJICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xyXG4gICAgICAgICAgICAgICAgKDxhbnk+dGhpcy4kd2luZG93KS5wcmV2ZW50QmxvY2tVSSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETyBNR0EgOiB1c2luZyBtZXRob2QgZnJvbSBMYXlvdXQuanMgOiB0byBkb2N1bWVudCB0byBub3QgaGFuZGxlIGR1cGxpY2F0ZSBjb2RlICEhXHJcbiAgICAgICAgLy9UT0RPIE1HQTogdW5yb2J1c3QsIG5lZWRzIHNvbGlkIHJlZmFjdG8gdG8gbWFrZSBpdCBtb3JlIGdlbmVyaWMgd2hlbiBvbiBvcmlnaW4gZG9tYWluICFcclxuICAgICAgICBwcml2YXRlIGdldFVybFBhdGgoYWN0aW9uSXNPblNhbWVDb250cm9sbGVyOiBib29sZWFuKTogc3RyaW5nIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBiYXNlVXJsT21BcHBzUmVnZXggPSAvKFxcL1xcdytcXC9cXChTXFwoXFx3K1xcKVxcKSlcXC9cXHcqLztcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmxBc3BBcHBzUmVnZXggPSAvKFxcL1xcdyspXFwvXFx3Ki87XHJcblxyXG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc01hdGNoZXMgPSBiYXNlVXJsT21BcHBzUmVnZXguZXhlYyh1cmwpO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNNYXRjaGVzID0gYmFzZVVybEFzcEFwcHNSZWdleC5leGVjKHVybCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTogc3RyaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGJhc2VVcmw6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyAyIG1hdGNoZXMgPSByZWdleCBtYXRjaGVzICsgdGhlIGNhcHR1cmluZyBncm91cFxyXG4gICAgICAgICAgICBpZiAoYmFzZVVybE9tQXBwc01hdGNoZXMgJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xyXG5cclxuICAgICAgICAgICAgICAgIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1swXTtcclxuICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsT21BcHBzTWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlVXJsQXNwQXBwc01hdGNoZXMgJiYgYmFzZVVybEFzcEFwcHNNYXRjaGVzLmxlbmd0aCAmJiBiYXNlVXJsQXNwQXBwc01hdGNoZXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gYmFzZVVybEFzcEFwcHNNYXRjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxBc3BBcHBzTWF0Y2hlc1sxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFjdGlvbklzT25TYW1lQ29udHJvbGxlciAmJiBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlVXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPIE1HQTogT00tc3BlY2lmaWMgQVNQIE1WQyBjb2RlLCBub3QgdXNlZCBBVE0sIHRvIHJlbW92ZVxyXG4gICAgICAgIHByaXZhdGUgZ2V0Q3VycmVudFNlc3Npb25JRCgpOiBzdHJpbmcge1xyXG5cclxuICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1hZ2ljIHJlZ2V4cCB0byBmZXRjaCBTZXNzaW9uSUQgaW4gVVJMLCB0byBzdG9yZSBlbHNld2hlcmUgIVxyXG4gICAgICAgICAgICB2YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9bXFx3Ll0rXFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuICAgICAgICAgICAgLy92YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9PcmRlckVudHJ5XFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXBkYXRlIHJlZ2V4cCB0byB0aGUgb25lIGJlbG93XHJcbiAgICAgICAgICAgIC8vdmFyIGJhc2VVcmxSZWdleCA9IC8oaHR0cHM6XFwvXFwvW1xcdy4tXStcXC9bXFx3Li1dK1xcL1xcKFNcXChcXHcrXFwpXFwpXFwvKVxcdysvO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy4kbG9jYXRpb24uYWJzVXJsKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVnZXhwQXJyYXkgPSBzZXNzaW9uUmVnZXguZXhlYyhwYXRoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghcmVnZXhwQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJlY29nbml6ZWQgc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybCBsb2NhdGlvbiB0byByZXRyaWV2ZSBzZXNzaW9uSUQuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdVbmFibGUgdG8gZmluZCBzZXNzaW9uSUQgaW4gc2VhcmNoZWQgcGF0dGVybiBpbiBjdXJyZW50IHVybC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVnZXhwQXJyYXkubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kbG9nLmVycm9yKCdUb28gbWFueSBtYXRjaGVzIGZvdW5kIGZvciB0aGUgc2Vzc2lvbklEIHNlYXJjaCBpbiB0aGUgY3VycmVudCB1cmwuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZWdleHBBcnJheVsxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaW0gdGhlIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIHRvIHJldHVybiBvbmx5IHRoZSBmaWxlbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJpdmF0ZSBnZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24oY29udGVudERpc3Bvc2l0aW9uSGVhZGVyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyLnNwbGl0KCc7JylbMV0udHJpbSgpLnNwbGl0KCc9JylbMV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1wiL2csICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vI2VuZHJlZ2lvblxyXG4gICAgfVxyXG5cclxuICAgIGFuZ3VsYXIubW9kdWxlKCduZy5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXHJcbiAgICAgICAgLy8gZG9uZSBpbiBjb25maWd1cmVIdHRwQ2FsbCBtZXRob2QuXHJcbiAgICAgICAgLy8uY29uZmlnKFsnJGh0dHBQcm92aWRlcicsICgkaHR0cFByb3ZpZGVyOiBuZy5JSHR0cFByb3ZpZGVyKSA9PiB7XHJcbiAgICAgICAgLy8gICAgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcclxuICAgICAgICAvL31dKVxyXG4gICAgICAgIC5zZXJ2aWNlKCdodHRwV3JhcHBlclNlcnZpY2UnLCBIdHRwV3JhcHBlclNlcnZpY2UpO1xyXG59IiwidmFyIGJsdWVza3k7XG4oZnVuY3Rpb24gKGJsdWVza3kpIHtcbiAgICB2YXIgY29yZTtcbiAgICAoZnVuY3Rpb24gKGNvcmUpIHtcbiAgICAgICAgdmFyIG1vZGVscztcbiAgICAgICAgKGZ1bmN0aW9uIChtb2RlbHMpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVE9ETyBNR0EgOiBleHBvcnQgYW4gaW50ZXJmYWNlIHRvbyA/XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBBcGlDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEFwaUNvbmZpZyhjb3JlQXBpVXJsLCBcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IHRvIGluamVjdCBhcyBnZW5lcmljIGxpc3Qgb2YgY3VzdG9tIGhlYWRlcnMgdG8gcGFzcyB0byAkaHR0cCBzZXJ2aWNlID9cbiAgICAgICAgICAgICAgICAgICAgand0VG9rZW4sIGN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcmVBcGlVcmwgPSBjb3JlQXBpVXJsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmp3dFRva2VuID0gand0VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFVzZXJSb2xlID0gY3VycmVudFVzZXJSb2xlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQXBpQ29uZmlnO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIG1vZGVscy5BcGlDb25maWcgPSBBcGlDb25maWc7XG4gICAgICAgIH0pKG1vZGVscyA9IGNvcmUubW9kZWxzIHx8IChjb3JlLm1vZGVscyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuXG52YXIgYmx1ZXNreTtcbihmdW5jdGlvbiAoYmx1ZXNreSkge1xuICAgIHZhciBjb3JlO1xuICAgIChmdW5jdGlvbiAoY29yZSkge1xuICAgICAgICB2YXIgbW9kZWxzO1xuICAgICAgICAoZnVuY3Rpb24gKG1vZGVscykge1xuICAgICAgICAgICAgdmFyIEZpbGVDb250ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGaWxlQ29udGVudChuYW1lLCBzaXplLCB0eXBlLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBGaWxlQ29udGVudDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICBtb2RlbHMuRmlsZUNvbnRlbnQgPSBGaWxlQ29udGVudDtcbiAgICAgICAgfSkobW9kZWxzID0gY29yZS5tb2RlbHMgfHwgKGNvcmUubW9kZWxzID0ge30pKTtcbiAgICB9KShjb3JlID0gYmx1ZXNreS5jb3JlIHx8IChibHVlc2t5LmNvcmUgPSB7fSkpO1xufSkoYmx1ZXNreSB8fCAoYmx1ZXNreSA9IHt9KSk7XG5cbnZhciBibHVlc2t5O1xuKGZ1bmN0aW9uIChibHVlc2t5KSB7XG4gICAgdmFyIGNvcmU7XG4gICAgKGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgIHZhciBzZXJ2aWNlcztcbiAgICAgICAgKGZ1bmN0aW9uIChzZXJ2aWNlcykge1xuICAgICAgICAgICAgdmFyIEh0dHBNZXRob2Q7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKEh0dHBNZXRob2QpIHtcbiAgICAgICAgICAgICAgICBIdHRwTWV0aG9kW0h0dHBNZXRob2RbXCJHRVRcIl0gPSAwXSA9IFwiR0VUXCI7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiUE9TVFwiXSA9IDFdID0gXCJQT1NUXCI7XG4gICAgICAgICAgICAgICAgSHR0cE1ldGhvZFtIdHRwTWV0aG9kW1wiUFVUXCJdID0gMl0gPSBcIlBVVFwiO1xuICAgICAgICAgICAgICAgIEh0dHBNZXRob2RbSHR0cE1ldGhvZFtcIkRFTEVURVwiXSA9IDNdID0gXCJERUxFVEVcIjtcbiAgICAgICAgICAgIH0pKEh0dHBNZXRob2QgfHwgKEh0dHBNZXRob2QgPSB7fSkpO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUT0RPIE1HQSA6IHRoaXMgbWF5IG5vdCBuZWVkIHRvIGJlIGEgZGVkaWNhdGVkIHNlcnZpY2UsIGl0IGNhbiBhbHNvIGJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBodHRwSW50ZXJjZXB0b3IuIERlY2lkZSBiZXN0IGFwcHJvYWNoIGRlcGVuZGluZyBvbiBwbGFubmVkIHVzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIEh0dHBXcmFwcGVyU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIGN0b3JcbiAgICAgICAgICAgICAgICAvKiBAbmdJbmplY3QgKi9cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBIdHRwV3JhcHBlclNlcnZpY2UoJGh0dHAsICR3aW5kb3csICRsb2csICRxLCAkbG9jYXRpb24sIFVwbG9hZCwgdG9hc3Rlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRodHRwID0gJGh0dHA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpbmRvdyA9ICR3aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZyA9ICRsb2c7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHEgPSAkcTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9jYXRpb24gPSAkbG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVXBsb2FkID0gVXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvYXN0ZXIgPSB0b2FzdGVyO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgKiBQcmVwYXJlcyBhIHtAbGluayBuZyMkaHR0cCNjb25maWcgY29uZmlnfSBvYmplY3QgZm9yICRodHRwIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgICogVGhlIG9wZXJhdGlvbnMgaW5jbHVkZSBzZXR0aW5nIGRlZmF1bHQgdmFsdWVzIHdoZW4gbm90IHByb3ZpZGVkLCBhbmQgc2V0dGluZyBodHRwIGhlYWRlcnMgaWYgbmVlZGVkIGZvciA6XG4gICAgICAgICAgICAgICAgICAgICogIC0gQWpheCBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAqICAtIEF1dGhvcml6YXRpb24gdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgKiAgLSBDdXJyZW50IFVzZXJSb2xlLlxuICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge25nLiRodHRwLmNvbmZpZ30gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHJlYWR5IHRvIGJlIGluamVjdGVkIGludG8gYSAkaHR0cCBjYWxsLlxuICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZUh0dHBDYWxsID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXJsIHx8IG1ldGhvZCA9PT0gbnVsbCB8fCBtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoJ1VSTCAmIE1FVEhPRCBwYXJhbWV0ZXJzIGFyZSBuZWNlc3NhcnkgZm9yIGh0dHBXcmFwcGVyIGNhbGxzLiBBYm9ydGluZy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSW5pdCBjb25maWcgZXZlbiBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhcmQgY2FzdCBpcyBub3Qgc2FmZSwgd2UgbWF5IGZvcmdldCB0byBzZXQgdXJsICYgbWV0aG9kIHBhcmFtZXRlcnMuIFRPRklYLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBnZXQgYWxsIG5vbi1maWx0ZXJlZCBwYXJhbWV0ZXJzICYga2VlcCB0aGVtIGZvciB0aGlzIG5ldyBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnRnVsbCA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHN1cHBvcnQgbWFwcGluZyBiZXR3ZWVuIHVwbG9hZCAmIHBvc3QgaGVyZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLm1ldGhvZCA9IEh0dHBNZXRob2RbbWV0aG9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuYXBpRW5kcG9pbnQgJiYgKCFfdGhpcy5hcGlDb25maWcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhX3RoaXMuYXBpQ29uZmlnLmp3dFRva2VuIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLmFwaUNvbmZpZy5jdXJyZW50VXNlclJvbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltJbnRlcm5hbEVycm9yXSBbXCIgKyBjb25maWdGdWxsLm1ldGhvZCArIFwiIC8gXCIgKyB1cmwgKyBcIl0gLSBjb3JlQXBpIGNhbGwgaW50ZW5kZWQgd2l0aG91dCBuZWNlc3NhcnkgY2FwaSBjcmVkZW50aWFscy4gQWJvcnRpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbmZpZy5hcGlFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwudXJsID0gX3RoaXMuYnVpbGRVcmxGcm9tQ29udGV4dCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGNvcmUgYXBpIGVuZHBvaW50ICdhcGkvJyBoYXJkY29kZWQsIHRvIHB1dCBpbiBjb25maWdGdWxsICEgc2hvdWxkIG5vdCBrbm93IHRoYXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdGdWxsLnVybCA9IF90aGlzLmFwaUNvbmZpZy5jb3JlQXBpVXJsICsgJ2FwaS8nICsgdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hcGlDb25maWcuand0VG9rZW4gJiYgX3RoaXMuYXBpQ29uZmlnLmN1cnJlbnRVc2VyUm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBoYXJkIGNvZGVkIGhlYWRlcnMsIG5vdCBnb29kLCB0byBpbmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydPQS1Vc2VyUm9sZSddID0gX3RoaXMuYXBpQ29uZmlnLmN1cnJlbnRVc2VyUm9sZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnRnVsbC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnQmVhcmVyICcgKyBfdGhpcy5hcGlDb25maWcuand0VG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuZGlzYWJsZVhtbEh0dHBSZXF1ZXN0SGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ0Z1bGwuaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IE9FIHNwZWNpZmljIGNvZGUsIHRvIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLiR3aW5kb3cuYmxvY2tfVUkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIE1HQSA6IHR5cGUgY2FzdGluZywgaXMgaXQgb2theSBvciBub3QgPyBiZXR0ZXIgYXBwcm9hY2ggP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiR3aW5kb3cucHJldmVudEJsb2NrVUkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ0Z1bGw7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTdWNjZXNzIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgICAgICAqIENhcHR1cmVzIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIGF0IHRoZSBtb21lbnQgb2YgaXRzIGRlY2xhcmF0aW9uICYgcmV0dXJuIHRoZSByZWFsIGhhbmRsZXIgdG8gYmUgY2FsbGVkIHVwb24gcHJvbWlzZSBjb21wbGV0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBJbnB1dCBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBjYWxsaW5nQ29uZmlnOiBjb25maWd1cmF0aW9uIHVzZWQgdG8gbWFrZSB0aGUgYWpheCBjYWxsLCBpbiBjYXNlIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIG51bGwvZW1wdHkgYW5kIGRvZXNuJ3QgY29udGFpbiBuZWNlc3NhcnkgZGF0YSBmb3IgZGVidWdnaW5nLlxuICAgICAgICAgICAgICAgICAgICAgKiAgLSBnZXRDb21wbGV0ZVJlc3BvbnNlT2JqZWN0OiBmbGFnIGluZGljYXRpb24gaWYgd2UgbXVzdCByZXR1cm4gdGhlIGZ1bGwgcmVzcG9uc2Ugb2JqZWN0IGFsb25nIHdpdGggaGVhZGVycyBhbmQgc3RhdHVzIG9yIG9ubHkgdGhlIGlubmVyIGRhdGEuIEJ5IGRlZmF1bHQgJiBpZiBub3Qgc3BlY2lmaWVkLCBvbmx5IHJldHVybnMgaW5uZXIgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWNjZXNzID0gZnVuY3Rpb24gKGh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcihcIltIVFRQIG5vLXJlc3BvbnNlXSBVbmV4cGVjdGVkICRodHRwIGVycm9yLCBubyByZXNwb25zZSBwcm9taXNlIHJldHVybmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLmVycm9yKCdVbmV4cGVjdGVkIGJlaGF2aW9yJywgJ1BsZWFzZSBjb250YWN0IHlvdXIgbG9jYWwgc3VwcG9ydCB0ZWFtLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFuZGxlIHdoZW4gQVBJIGlzIGZpeGVkLiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTc0Njg5NC93aGF0LWlzLXRoZS1wcm9wZXItcmVzdC1yZXNwb25zZS1jb2RlLWZvci1hLXZhbGlkLXJlcXVlc3QtYnV0LWFuLWVtcHR5LWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKChwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gbnVsbCB8fCBwcm9taXNlQ2FsbGJhY2suZGF0YSA9PT0gdW5kZWZpbmVkKSAmJiBwcm9taXNlQ2FsbGJhY2suc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHRoaXMuJGxvZy5lcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIGV4cGVjdGVkIHJlc3BvbnNlIGRhdGEgYnV0IG5vbmUgZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0aGlzLnRvYXN0ZXIud2FybmluZygnVW5leHBlY3RlZCByZXNwb25zZScsICdQbGVhc2UgY29udGFjdCB5b3VyIGxvY2FsIHN1cHBvcnQgdGVhbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHJldHVybiB0aGlzLiRxLnJlamVjdChwcm9taXNlQ2FsbGJhY2spOyAvLyBSZWplY3QgcHJvbWlzZSBpZiBub3Qgd2VsbC1mb3JtZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBzYW1lIGJlaGF2aW9yIGFsc28gb24gYSBHRVQgcmVxdWVzdCA/IGlmIHJlcXVlc3QgaXMgR0VUIGFuZCByZXNwb25zZSBpcyAyMDAgd2l0aCBubyBkYXRhLCByZXR1cm4gZXJyb3IgPyAocGFzcyBpbiBwYXJhbWV0ZXIgcmVxdWVzdCBjb250ZXh0IHRvIGxvZyB0aGlzIGVycm9yKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGdldCBmdWxsIHVybCBvZiByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbG9nLmRlYnVnKFwiW0hUVFAgXCIgKyBodHRwUHJvbWlzZS5jb25maWcubWV0aG9kICsgXCJdIFtcIiArIGh0dHBQcm9taXNlLmNvbmZpZy51cmwgKyBcIl1cIiwgaHR0cFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIG9ubHkgdGhlIGRhdGEgZXhwZWN0ZWQgZm9yIGNhbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBQcm9taXNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBFcnJvciBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBodHRwUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yID0gZnVuY3Rpb24gKGh0dHBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdXBwb3NlIGluIGNhc2Ugb2Ygbm8gcmVzcG9uc2UgdGhhdCB0aGUgc3J2IGRpZG4ndCBzZW5kIGFueSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBOiBtYXkgYWxzbyBiZSBhIGZhdWx0IGluIGludGVybmFsICRodHRwIC8gYWpheCBjbGllbnQgc2lkZSBsaWIsIHRvIGRpc3Rpbmd1aXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFodHRwUHJvbWlzZSB8fCAhaHR0cFByb21pc2UuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBQcm9taXNlLmRhdGEgPSAnU2VydmVyIG5vdCByZXNwb25kaW5nJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwUHJvbWlzZS5zdGF0dXMgPSA1MDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBodHRwUHJvbWlzZS5oZWFkZXJzKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAmJiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlwiOyAvL2RlZmF1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBlcnJvciBoYW5kbGluZyBtb3JlIGdlbmVyaWNhbGx5IGJhc2VkIG9uIGlucHV0IGVycm9yIG1lc3NhZ2UgY29udHJhY3QgaW5zdGVhZCBvZiBleHBlY3Rpbmcgc3BlY2lmaWMgZXJyb3Igc3RyY3R1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAocmVzcG9uc2UuZGF0YS5Nb2RlbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgLy9UT0RPIE1HQSA6IGhhbmRsZSB0aGlzIHdoZW4gd2VsbCBmb3JtYXR0ZWQgc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL30gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UgJiYgYW5ndWxhci5pc1N0cmluZyhodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBodHRwUHJvbWlzZS5kYXRhLk1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcoaHR0cFByb21pc2UuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGh0dHBQcm9taXNlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IGhhbmRsZSBtb3JlIHJlc3BvbnNlIGNvZGVzIGdyYWNlZnVsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0dHBQcm9taXNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIud2FybmluZygnTm90IEZvdW5kJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2FzdGVyLmVycm9yKCdTZXJ2ZXIgcmVzcG9uc2UgZXJyb3InLCBtZXNzYWdlICsgJ1xcbiBTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0ZXIuZXJyb3IoJ0ludGVybmFsIHNlcnZlciBlcnJvcicsICdTdGF0dXM6ICcgKyBodHRwUHJvbWlzZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogZ2V0IGZ1bGwgdXJsIG9mIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRsb2cuZXJyb3IoXCJbSFRUUCBcIiArIGh0dHBQcm9taXNlLmNvbmZpZy5tZXRob2QgKyBcIl0gW1wiICsgaHR0cFByb21pc2UuY29uZmlnLnVybCArIFwiXVwiLCBodHRwUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCByZWNvdmVyIGZyb20gZXJyb3IsIHNvIHdlIHByb3BhZ2F0ZSBpdCA6IGJlbG93IGhhbmRsZXJzIGhhdmUgdGhlIGNob2ljZSBvZiByZWFkaW5nIHRoZSBlcnJvciB3aXRoIGFuIGVycm9yIGhhbmRsZXIgb3Igbm90LiBTZWUgJHEgcHJvbWlzZXMgYmVoYXZpb3IgaGVyZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBkZXNpcmVkIHNvIHRoYXQgd2Ugc2hvdyBlcnJvciBpbnNpZGUgc3BlY2lmaWMgc2VydmVyIGNvbW11bmljYXRpb24gbW9kYWxzIGF0IHNwZWNpZmljIHBsYWNlcyBpbiB0aGUgYXBwLCBvdGhlcndpc2Ugc2hvdyBhIGdsb2JhbCBhbGVydCBtZXNzYWdlLCBvciBldmVuIGRvIG5vdCBzaG93IGFueXRoaW5nIGlmIG5vdCBuZWNlc3NhcnkgKGRvIG5vdCBhZCBhbiBlcnJvciBoYW5kbGVyIGluIGJlbG93IGhhbmRsZXJzIG9mIHRoaXMgcHJvbWlzZSkuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHEucmVqZWN0KGh0dHBQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9uIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuIGFqYXggY2FsbCwgcmVnYXJkbGVzcyBvZiBpdCdzIHN1Y2Nlc3Mgb3IgZmFpbHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBPRS1zcGVjaWZpYyBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuJHdpbmRvdy5ibG9ja19VSSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdHlwZSBjYXN0aW5nLCBpcyBpdCBva2F5IG9yIG5vdCA/IGJldHRlciBhcHByb2FjaCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJHdpbmRvdy5wcmV2ZW50QmxvY2tVSSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBpbml0IGNvcmUgYXBpIGNvbmZpZyBkYXRhIG9uIGN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGhhcmQgY29kZWQgcGF0aCBmb3IgQ29yZXJBcGlBdXRoQ3RybCB0byBpbmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0UHJvbWlzZSA9IHRoaXMuJGh0dHAuZ2V0KHRoaXMuYnVpbGRVcmxGcm9tQ29udGV4dCgnQ29yZUFwaUF1dGgvR2V0Q29yZUFwaUNvbmZpZycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1Y2Nlc3MoZnVuY3Rpb24gKGNvcmVBcGlDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFwaUNvbmZpZyA9IGNvcmVBcGlDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIHJldHJpZXZlIEFQSSBjb25maWcuIEFib3J0aW5nIGh0dHBXcmFwcGVyU2VydmljZSBpbml0aWFsaXphdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8jZW5kcmVnaW9uXG4gICAgICAgICAgICAgICAgLy8jcmVnaW9uIHB1YmxpYyBtZXRob2RzXG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLkdFVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLkRFTEVURSwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRhdGEgPSBkYXRhIHx8IGNvbmZpZy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXgoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gZGF0YSB8fCBjb25maWcuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheChIdHRwTWV0aG9kLlBVVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS51cGxvYWQgPSBmdW5jdGlvbiAodXJsLCBmaWxlLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlICYmICghY29uZmlnIHx8ICFjb25maWcuZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignQ2Fubm90IHN0YXJ0IHVwbG9hZCB3aXRoIG51bGwge2ZpbGV9IHBhcmFtZXRlci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmZpbGUgPSBmaWxlIHx8IGNvbmZpZy5maWxlOyAvL1RPRE8gTUdBIDogZG8gbm90IGV4cG9zZSBmaWxlIGluIElIdHRwV3JhcHBlckNvbmZpZyA/XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcudXBsb2FkSW5CYXNlNjRKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBOiBtYWtlIHN1cmUgdGhpcyBkZWxheXMgbmV4dCBjYWxsIGFuZCB1cGxvYWQgaXMgbm90IGRvbmUgYmVmb3JlIGJhc2U2NCBlbmNvZGluZyBpcyBmaW5pc2hlZCwgZXZlbiBpZiBwcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQgPz8/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VcGxvYWQuYmFzZTY0RGF0YVVybChmaWxlKS50aGVuKGZ1bmN0aW9uIChmaWxlQmFzZTY0VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogaGFyZC1jb2RlZCBrZXkgdG8gZmV0Y2ggYmFzZTY0IGVuY29kaW5nLCB0byBwYXJhbWV0cml6ZSB3aXRoIHNlcnZlci1zaWRlICFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlQmFzZTY0VXJsID0gZmlsZUJhc2U2NFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vcm1hbCBwb3N0IGluIGNhc2Ugb2YgYmFzZTY0LWVuY29kZWQgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hamF4KEh0dHBNZXRob2QuUE9TVCwgdXJsLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZGF0YS5maWxlRm9ybURhdGFOYW1lID0gJ2ZpbGUnOyAvLyBmaWxlIGZvcm1EYXRhIG5hbWUgKCdDb250ZW50LURpc3Bvc2l0aW9uJyksIHNlcnZlciBzaWRlIHJlcXVlc3QgZm9ybSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogbm90IHNhZmUgaGFyZCBjYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IGJlaGF2aW9yIGR1cGxpY2F0aW9uIHdpdGggdGhpcy5hamF4LCBub3QgRFJZLCB0byBpbXByb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLlVwbG9hZC51cGxvYWQoX3RoaXMuY29uZmlndXJlSHR0cENhbGwoSHR0cE1ldGhvZC5QT1NULCB1cmwsIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKF90aGlzLm9uU3VjY2VzcywgX3RoaXMub25FcnJvciwgY29uZmlnLnVwbG9hZFByb2dyZXNzKSAvL1RPRE8gTUdBIDogdXBsb2FkUHJvZ3Jlc3MgY2FsbGJhY2sgb2sgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShfdGhpcy5maW5hbGx5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGRvd25sb2FkIGEgZmlsZSBpbiB0aGUgZm9ybSBvZiBhIGJ5dGUtc3RyZWFtIGZyb20gYW4gZW5kcG9pbnQgYW5kIHdyYXAgaXQgaW50byBhIEZpbGVDb250ZW50IG9iamVjdCB3aXRoIG5hbWUsIHR5cGUgJiBzaXplIHByb3BlcnRpZXMgcmVhZCBmcm9tIHRoZSBIVFRQIHJlc3BvbnNlIGhlYWRlcnMgb2YgdGhlIHNlcnZldXIuXG4gICAgICAgICAgICAgICAgICogSXQgaXMgdGhlIHJlc3BvbnNhYmlsaXR5IG9mIHRoZSBjb25zdW1lciB0byBkbyBzb21ldGhpbmcgd2l0aCB0aGUgd3JhcHBlZCBieXRlQXJyYXkgKGZvciBleGFtcGxlIGRvd25sb2FkIHRoZSBmaWxlLCBvciBzaG93IGl0IGluc2lkZSB0aGUgd2ViUGFnZSBldGMpLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXhwZWN0ZWROYW1lXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4cGVjdGVkU2l6ZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHBlY3RlZFR5cGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5nZXRGaWxlID0gZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ3VsYXJIdHRwQ29uZmlnID0gX3RoaXMuY29uZmlndXJlSHR0cENhbGwoSHR0cE1ldGhvZC5HRVQsIHVybCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljYWxseSBleHBlY3QgcmF3IHJlc3BvbnNlIHR5cGUsIG90aGVyd2lzZSBieXRlIHN0cmVhbSByZXNwb25zZXMgYXJlIGNvcnJ1cHRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJIdHRwQ29uZmlnLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0V4cGVjdGVkIEFycmF5QnVmZmVyIHJlc3BvbnNlID0gYnl0ZSBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRodHRwKGFuZ3VsYXJIdHRwQ29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChodHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2JlbmVmaXQgZnJvbSBzdWNjZXNzQ2FsbGJhY2sgdmFsaWRhdGlvbiBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IF90aGlzLm9uU3VjY2VzcyhodHRwUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHByb21pc2UgcmVqZWN0aW9uIHZzLiByZXR1cm4gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vc3RvcCBwcm9jZXNzaW5nIGlmIHVuYWJsZSB0byByZXRyaWV2ZSBieXRlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWFkIGZpbGUgaW5mbyBmcm9tIHJlc3BvbnNlLWhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZUNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzLmdldEZpbGVOYW1lRnJvbUhlYWRlckNvbnRlbnREaXNwb3NpdGlvbihodHRwUmVzcG9uc2UuaGVhZGVycygnY29udGVudC1kaXNwb3NpdGlvbicpKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBOdW1iZXIoaHR0cFJlc3BvbnNlLmhlYWRlcnMoJ2NvbnRlbnQtbGVuZ3RoJykpIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGh0dHBSZXNwb25zZS5oZWFkZXJzKCdjb250ZW50LXR5cGUnKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLm9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoX3RoaXMuZmluYWxseSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1ldGhvZCB0b28gc3BlY2lmaWMgdG8gT00gYXBwcyBjb250ZXh0LCBtYXkgbm90IHdvcmsgb3V0c2lkZSBvZiBpdCwgdG8gYWRhcHQgZm9yIHB1YmxpYyB1c2UgP1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRyaWVzIHRvIHBhcnNlIHRoZSBpbnB1dCB1cmwgOlxuICAgICAgICAgICAgICAgICAqIElmIGl0IHNlZW1zIHRvIGJlIGEgZnVsbCBVUkwsIHRoZW4gcmV0dXJuIGFzIGlzIChjb25zaWRlcnMgaXQgZXh0ZXJuYWwgVXJsKVxuICAgICAgICAgICAgICAgICAqIE90aGVyd2lzZSwgdHJpZXMgdG8gZmluZCB0aGUgYmFzZSBVUkwgb2YgdGhlIGN1cnJlbnQgQmx1ZVNreSBhcHAgd2l0aCBvciB3aXRob3V0IHRoZSBpbmNsdWRlZCBDb250cm9sbGVyIGFuZCByZXR1cm5zIHRoZSBmdWxsIFVybFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB1cmxJbnB1dCA6IFRPRE8gTUdBOiBkb2N1bWVudCBkaWZmZXJlbnQga2luZCBvZiB1cmxzIHRoYXQgdGhpcyBtZXRob2QgY2FuIHRha2UgYXMgaW5wdXQgKGZ1bGwsIHBhcnRpYWwgZXRjKVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUuYnVpbGRVcmxGcm9tQ29udGV4dCA9IGZ1bmN0aW9uICh1cmxJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAxIC0gVXJsIHN0YXJ0cyB3aXRoIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gPT4gcmV0dXJuIGFzIGlzLlxuICAgICAgICAgICAgICAgICAgICBpZiAodXJsSW5wdXQuc2xpY2UoMCwgJ2h0dHA6Ly8nLmxlbmd0aCkgPT09ICdodHRwOi8vJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsSW5wdXQuc2xpY2UoMCwgJ2h0dHBzOi8vJy5sZW5ndGgpID09PSAnaHR0cHM6Ly8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gMiAtIE90aGVyd2lzZSwgdHJ5IHRvIGZpbmQgY29ycmVjdCBjb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gdXNlZCB0byB0cnkgdG8gZGV0ZXJtaW5lIGNvcnJlY3QgZnVsbCB1cmwgKGFkZCAvIG9yIG5vdCBiZWZvcmUgdGhlIHVybCBmcmFnbWVudCBkZXBlbmRpbmcgb24gaWYgZm91bmQgb3Igbm90KVxuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsRnJhZ21lbnRTdGFydHNXaXRoU2xhc2ggPSB1cmxJbnB1dC5zbGljZSgwLCAnLycubGVuZ3RoKSA9PT0gJy8nO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWdleCB0cnlpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSBpbnB1dCBmcmFnbWVudCBjb250YWlucyBhIC8gYmV0d2VlbiB0d28gY2hhcmFjdGVyIHN1aXRlcyA9PiBjb250cm9sbGVyIGdpdmVuIGFzIGlucHV0LCBvdGhlcndpc2UsIGFjdGlvbiBvbiBzYW1lIGNvbnRyb2xsZXIgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJc1ByZXNlbnRSZWdleCA9IC9cXHcrXFwvXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgPSAhY29udHJvbGxlcklzUHJlc2VudFJlZ2V4LnRlc3QodXJsSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybCA9IHRoaXMuZ2V0VXJsUGF0aChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVVybCArICh1cmxGcmFnbWVudFN0YXJ0c1dpdGhTbGFzaCA/IHVybElucHV0IDogKCcvJyArIHVybElucHV0KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyNlbmRyZWdpb25cbiAgICAgICAgICAgICAgICAvLyNyZWdpb24gcHJpdmF0ZSBtZXRob2RzXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXRpbGl0eSBtZXRob2QuXG4gICAgICAgICAgICAgICAgICogTWFpbiBjYWxsZXIgdGhhdCBhbGwgd3JhcHBlciBjYWxscyAoZ2V0LCBkZWxldGUsIHBvc3QsIHB1dCkgbXVzdCB1c2UgdG8gc2hhcmUgY29tbW9uIGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBIdHRwV3JhcHBlclNlcnZpY2UucHJvdG90eXBlLmFqYXggPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogbWFrZSBzdXJlIGluaXRQcm9taXNlIHJlc29sdmUgYXV0b21hdGljYWxseSB3aXRob3V0IG92ZXJoZWFkIG9uY2UgZmlyc3QgY2FsbCBzdWNlc3NmdWxsLlxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gTUdBIDogZG8gbm90IGJsb2NrIGlmIG5vdCBjYWxsIHRvIGludGVybmFsIEFQSSAoaW5pdENhbGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ3VsYXJIdHRwQ29uZmlnID0gX3RoaXMuY29uZmlndXJlSHR0cENhbGwobWV0aG9kLCB1cmwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGh0dHAoYW5ndWxhckh0dHBDb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oX3RoaXMub25TdWNjZXNzLCBfdGhpcy5vbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KF90aGlzLmZpbmFsbHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gTUdBIDogdXNpbmcgbWV0aG9kIGZyb20gTGF5b3V0LmpzIDogdG8gZG9jdW1lbnQgdG8gbm90IGhhbmRsZSBkdXBsaWNhdGUgY29kZSAhIVxuICAgICAgICAgICAgICAgIC8vVE9ETyBNR0E6IHVucm9idXN0LCBuZWVkcyBzb2xpZCByZWZhY3RvIHRvIG1ha2UgaXQgbW9yZSBnZW5lcmljIHdoZW4gb24gb3JpZ2luIGRvbWFpbiAhXG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5nZXRVcmxQYXRoID0gZnVuY3Rpb24gKGFjdGlvbklzT25TYW1lQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc1JlZ2V4ID0gLyhcXC9cXHcrXFwvXFwoU1xcKFxcdytcXClcXCkpXFwvXFx3Ki87XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsQXNwQXBwc1JlZ2V4ID0gLyhcXC9cXHcrKVxcL1xcdyovO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gdGhpcy4kd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybE9tQXBwc01hdGNoZXMgPSBiYXNlVXJsT21BcHBzUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVVybEFzcEFwcHNNYXRjaGVzID0gYmFzZVVybEFzcEFwcHNSZWdleC5leGVjKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVXJsV2l0aENvbnRyb2xsZXJOYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VVcmwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyAyIG1hdGNoZXMgPSByZWdleCBtYXRjaGVzICsgdGhlIGNhcHR1cmluZyBncm91cFxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVVybE9tQXBwc01hdGNoZXMgJiYgYmFzZVVybE9tQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxPbUFwcHNNYXRjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSA9IGJhc2VVcmxPbUFwcHNNYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IGJhc2VVcmxPbUFwcHNNYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJhc2VVcmxBc3BBcHBzTWF0Y2hlcyAmJiBiYXNlVXJsQXNwQXBwc01hdGNoZXMubGVuZ3RoICYmIGJhc2VVcmxBc3BBcHBzTWF0Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWUgPSBiYXNlVXJsQXNwQXBwc01hdGNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gYmFzZVVybEFzcEFwcHNNYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25Jc09uU2FtZUNvbnRyb2xsZXIgJiYgYmFzZVVybFdpdGhDb250cm9sbGVyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmxXaXRoQ29udHJvbGxlck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmFzZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy9UT0RPIE1HQTogT00tc3BlY2lmaWMgQVNQIE1WQyBjb2RlLCBub3QgdXNlZCBBVE0sIHRvIHJlbW92ZVxuICAgICAgICAgICAgICAgIEh0dHBXcmFwcGVyU2VydmljZS5wcm90b3R5cGUuZ2V0Q3VycmVudFNlc3Npb25JRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIE1HQSA6IG1hZ2ljIHJlZ2V4cCB0byBmZXRjaCBTZXNzaW9uSUQgaW4gVVJMLCB0byBzdG9yZSBlbHNld2hlcmUgIVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9bXFx3Ll0rXFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgc2Vzc2lvblJlZ2V4ID0gL2h0dHBzOlxcL1xcL1tcXHcuXStcXC9PcmRlckVudHJ5XFwvKFxcKFNcXChcXHcrXFwpXFwpKVxcLy4qLztcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBNR0EgOiB1cGRhdGUgcmVnZXhwIHRvIHRoZSBvbmUgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgYmFzZVVybFJlZ2V4ID0gLyhodHRwczpcXC9cXC9bXFx3Li1dK1xcL1tcXHcuLV0rXFwvXFwoU1xcKFxcdytcXClcXClcXC8pXFx3Ky87XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy4kbG9jYXRpb24uYWJzVXJsKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdleHBBcnJheSA9IHNlc3Npb25SZWdleC5leGVjKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4cEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2cuZXJyb3IoJ1VuYWJsZSB0byByZWNvZ25pemVkIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwgbG9jYXRpb24gdG8gcmV0cmlldmUgc2Vzc2lvbklELicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleHBBcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVW5hYmxlIHRvIGZpbmQgc2Vzc2lvbklEIGluIHNlYXJjaGVkIHBhdHRlcm4gaW4gY3VycmVudCB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2V4cEFycmF5Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvZy5lcnJvcignVG9vIG1hbnkgbWF0Y2hlcyBmb3VuZCBmb3IgdGhlIHNlc3Npb25JRCBzZWFyY2ggaW4gdGhlIGN1cnJlbnQgdXJsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdleHBBcnJheVsxXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRyaW0gdGhlIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIHRvIHJldHVybiBvbmx5IHRoZSBmaWxlbmFtZS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY29udGVudERpc3Bvc2l0aW9uSGVhZGVyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgSHR0cFdyYXBwZXJTZXJ2aWNlLnByb3RvdHlwZS5nZXRGaWxlTmFtZUZyb21IZWFkZXJDb250ZW50RGlzcG9zaXRpb24gPSBmdW5jdGlvbiAoY29udGVudERpc3Bvc2l0aW9uSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudERpc3Bvc2l0aW9uSGVhZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb250ZW50RGlzcG9zaXRpb25IZWFkZXIuc3BsaXQoJzsnKVsxXS50cmltKCkuc3BsaXQoJz0nKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSHR0cFdyYXBwZXJTZXJ2aWNlO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIHNlcnZpY2VzLkh0dHBXcmFwcGVyU2VydmljZSA9IEh0dHBXcmFwcGVyU2VydmljZTtcbiAgICAgICAgICAgIGFuZ3VsYXIubW9kdWxlKCduZy5odHRwV3JhcHBlcicsIFsndG9hc3RlcicsICduZ0FuaW1hdGUnLCAnbmdGaWxlVXBsb2FkJ10pXG4gICAgICAgICAgICAgICAgLnNlcnZpY2UoJ2h0dHBXcmFwcGVyU2VydmljZScsIEh0dHBXcmFwcGVyU2VydmljZSk7XG4gICAgICAgIH0pKHNlcnZpY2VzID0gY29yZS5zZXJ2aWNlcyB8fCAoY29yZS5zZXJ2aWNlcyA9IHt9KSk7XG4gICAgfSkoY29yZSA9IGJsdWVza3kuY29yZSB8fCAoYmx1ZXNreS5jb3JlID0ge30pKTtcbn0pKGJsdWVza3kgfHwgKGJsdWVza3kgPSB7fSkpO1xuIl19
